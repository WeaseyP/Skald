package skald_codegen

import "core:fmt"
import "core:os"
import "core:strings"
import "core:math"

import json "core:encoding/json"

// --- Data Structures (Unchanged) ---
Vec2 :: struct {
	x: f32,
	y: f32,
}
Node :: struct {
	id:         int,
	type:       string,
	position:   Vec2,
	parameters: json.Object,
}
Connection :: struct {
	from_node: int,
	from_port: string,
	to_node:   int,
	to_port:   string,
}
Graph :: struct {
	nodes:       []Node,
	connections: []Connection,
}

// --- Main Program ---
main :: proc() {
	// 1. Read and Parse JSON (Unchanged)
	input_bytes, read_err := os.read_entire_file_from_handle(os.stdin)
	if read_err != true {
		fmt.eprintf("Error reading from stdin: %v\n", read_err)
		os.exit(1)
	}
	graph: Graph
	parse_err := json.unmarshal(input_bytes, &graph)
	if parse_err != nil {
		fmt.eprintf("Error parsing JSON: %v\n", parse_err)
		os.exit(1)
	}

	// 3. Generate Functional Odin Code
	sb := strings.builder_make()
	defer strings.builder_destroy(&sb)

	strings.write_string(&sb, "package generated_audio\n\n")
	strings.write_string(&sb, "import \"core:math\"\n\n")
	strings.write_string(&sb, "// --- Code generated by Skald --- //\n\n")

	// --- 3a. Generate Node Structs ---
	for node in graph.nodes {
		switch node.type {
		case "Oscillator":
			// CORRECTED: Escaped the braces with {{ and }}
			fmt.sbprintf(&sb, "Oscillator_%d_State :: struct {{\n", node.id)
			fmt.sbprintf(&sb, "\tphase: f32,\n")
			fmt.sbprintf(&sb, "}}\n\n")
		}
	}

	// --- 3b. Generate the Main Processor Struct ---
	// CORRECTED: Escaped the braces with {{ and }}
	strings.write_string(&sb, "AudioProcessor :: struct {{\n")
	for node in graph.nodes {
		switch node.type {
		case "Oscillator":
			fmt.sbprintf(&sb, "\tosc_%d: Oscillator_%d_State,\n", node.id, node.id)
		}
	}
	strings.write_string(&sb, "}}\n\n")

	// --- 3c. Generate the Processing Function ---
	// CORRECTED: Escaped the braces with {{ and }}
	strings.write_string(&sb, "process_sample :: proc(p: ^AudioProcessor, sample_rate: f32) -> (left: f32, right: f32) {{\n")
	
	// Declare variables for the output of each node
	for node in graph.nodes {
		fmt.sbprintf(&sb, "\t// Node %d: %s\n", node.id, node.type)
		fmt.sbprintf(&sb, "\tnode_%d_out: f32\n", node.id)
	}
	strings.write_string(&sb, "\n")

	// Generate processing logic for each node
	for node in graph.nodes {
		switch node.type {
		case "Oscillator":
			freq: f64 = 440.0
			amp: f64 = 0.5
			if freq_val, ok := node.parameters["frequency"]; ok { if f, ok2 := freq_val.(f64); ok2 { freq = f } }
			if amp_val, ok := node.parameters["amplitude"]; ok { if a, ok2 := amp_val.(f64); ok2 { amp = a } }

			fmt.sbprintf(&sb, "\t// Processing for Oscillator %d\n", node.id)
			// NOTE: We can use sbprintf for complex lines and simple write_string for lines with no variables for clarity.
			fmt.sbprintf(&sb, "\tnode_%d_out = f32(math.sin(p.osc_%d.phase) * %f);\n", node.id, node.id, amp)
			fmt.sbprintf(&sb, "\tp.osc_%d.phase += 2 * math.PI * %f / sample_rate;\n", node.id, freq)
			// CORRECTED: Escaped the braces with {{ and }}
			fmt.sbprintf(&sb, "\tif p.osc_%d.phase > 2 * math.PI {{ p.osc_%d.phase -= 2 * math.PI; }}\n\n", node.id, node.id)

		case "GraphOutput":
			input_source_node_id := -1
			for conn in graph.connections {
				if conn.to_node == node.id {
					input_source_node_id = conn.from_node
					break
				}
			}

			if input_source_node_id != -1 {
				fmt.sbprintf(&sb, "\t// Output connected to Node %d\n", input_source_node_id)
				fmt.sbprintf(&sb, "\tnode_%d_out = node_%d_out;\n", node.id, input_source_node_id)
			} else {
				strings.write_string(&sb, "\t// Output is not connected, will be silent\n")
				fmt.sbprintf(&sb, "\tnode_%d_out = 0.0;\n", node.id)
			}
			
			fmt.sbprintf(&sb, "\treturn node_%d_out, node_%d_out;\n", node.id, node.id)
		}
	}

	strings.write_string(&sb, "}}\n") // CORRECTED: Escaped the final brace

	// 4. Print the final generated code to standard output
	fmt.printf("%s", strings.to_string(sb))
}