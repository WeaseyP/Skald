// File: main.odin
// The headless Odin CLI for Skald code generation. (Corrected and Improved)
package skald_codegen

import "core:fmt"
import "core:os"
import "core:strings"

// Corrected import path and aliased to 'json' for convenience
import json "core:encoding/json"

// --- Data Structures to Match the JSON Contract ---

Vec2 :: struct {
	x: f32,
	y: f32,
}

// Corrected: The type for a sub-object is `json.Object`,
// which is an alias for `map[string]json.Value`.
Node :: struct {
	id:         int,
	type:       string,
	position:   Vec2,
	parameters: json.Object,
}

Connection :: struct {
	from_node: int,
	from_port: string,
	to_node:   int,
	to_port:   string,
}

Graph :: struct {
	nodes:       []Node,
	connections: []Connection,
}

// --- Main Program ---

main :: proc() {
	// 1. Read all data from standard input
	input_bytes, read_err := os.read_entire_file_from_handle(os.stdin)
	if read_err != true {
		fmt.eprintf("Error reading from stdin: %v\n", read_err)
		os.exit(1)
	}

	// 2. Parse the input bytes as a Graph JSON object
	graph: Graph
	// Corrected error handling: The `unmarshal` procedure returns a union that
	// is `nil` on success. We check if it is not nil.
	parse_err := json.unmarshal(input_bytes, &graph)
	if parse_err != nil {
		fmt.eprintf("Error parsing JSON: %v\n", parse_err)
		os.exit(1)
	}

	// 3. Generate Odin code
	sb := strings.builder_make()
	defer strings.builder_destroy(&sb)

	strings.write_string(&sb, "package generated_audio\n\n")
	strings.write_string(&sb, "// Code generated by Skald\n\n")

	// Improved Generation Logic: We now properly inspect the parameters
	for node in graph.nodes {
		switch node.type {
		case "Oscillator":
			// Safely extract parameters from the `json.Object` map
			// Default values are used if a parameter is missing
			freq: f64 = 440.0
			amp: f64 = 0.5
			waveform: string = "Sine"

			// Check for 'frequency'
			if freq_val, ok := node.parameters["frequency"]; ok {
				// Type-assert the json.Value to the type we expect (f64)
				if f, ok2 := freq_val.(f64); ok2 {
					freq = f
				}
			}
			// Check for 'amplitude'
			if amp_val, ok := node.parameters["amplitude"]; ok {
				if a, ok2 := amp_val.(f64); ok2 {
					amp = a
				}
			}
			// Check for 'waveform'
			if wf_val, ok := node.parameters["waveform"]; ok {
				if w, ok2 := wf_val.(string); ok2 {
					waveform = w
				}
			}

			fmt.sbprintf(&sb, "// Node %d: Oscillator\n", node.id)
			fmt.sbprintf(&sb, "osc_%d_freq :: %f\n", node.id, freq)
			fmt.sbprintf(&sb, "osc_%d_amp :: %f\n", node.id, amp)
			fmt.sbprintf(&sb, "osc_%d_waveform :: \"%s\"\n\n", node.id, waveform)

		case "GraphOutput":
			fmt.sbprintf(&sb, "// Node %d: Graph Output\n\n", node.id)

		case:
			// Handle other node types in the future
			fmt.sbprintf(&sb, "// Node %d: Unrecognized type '%s'\n\n", node.id, node.type)
		}
	}

	for conn in graph.connections {
		fmt.sbprintf(&sb, "// Connection from node %d (%s) to node %d (%s)\n",
			conn.from_node, conn.from_port, conn.to_node, conn.to_port)
	}

	// 4. Print the final generated code to standard output
	fmt.printf("%s", strings.to_string(sb))
}