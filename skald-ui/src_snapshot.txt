Project snapshot for: src
Generated with 35 files.

--- START FILE: app.tsx ---

/*
================================================================================
| FILE: skald-ui/src/app.tsx (Refactored)                                      |
|                                                                              |
| The main app component is now much cleaner. It's responsible for initializing|
| the hooks and rendering the UI layout, passing down the state and functions  |
| from the hooks to the appropriate child components.                          |
================================================================================
*/
import React, { useMemo, useRef, useState } from 'react';
import ReactFlow, { Background, Controls, ReactFlowInstance, ReactFlowProvider, Node } from 'reactflow';
import 'reactflow/dist/style.css';

// Import your components
import Sidebar from './components/Sidebar';
import ParameterPanel from './components/ParameterPanel';
import CodePreviewPanel from './components/CodePreviewPanel';
import NamePromptModal from './components/NamePromptModal';
import { 
    OscillatorNode, FilterNode, GraphOutputNode, NoiseNode, ADSRNode, 
    LFONode, SampleHoldNode, DelayNode, ReverbNode, DistortionNode, 
    MixerNode, PannerNode, GroupNode, FmOperatorNode, WavetableNode 
} from './components/Nodes';
import InstrumentNode from './components/InstrumentNode';


// Import your new hooks
import { useGraphState } from './hooks/nodeEditor/useGraphState';
import { useAudioEngine } from './hooks/nodeEditor/useAudioEngine';
import { useFileIO } from './hooks/nodeEditor/useFileIO';

const appContainerStyles: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'row',
    width: '100vw',
    height: '100vh',
    backgroundColor: '#1E1E1E',
};

const sidebarPanelStyles: React.CSSProperties = {
    width: '200px',
    backgroundColor: '#252526',
    borderRight: '1px solid #333',
};

const mainCanvasStyles: React.CSSProperties = {
    flexGrow: 1,
    height: '100%',
};

const parameterPanelStyles: React.CSSProperties = {
    width: '350px',
    backgroundColor: '#252526',
    borderLeft: '1px solid #333',
};

// Define nodeTypes outside the component to prevent re-creation on every render.
const nodeTypes = { 
    oscillator: OscillatorNode,
    filter: FilterNode,
    output: GraphOutputNode,
    noise: NoiseNode,
    adsr: ADSRNode,
    lfo: LFONode, 
    instrument: InstrumentNode,
    sampleHold: SampleHoldNode,
    delay: DelayNode,
    reverb: ReverbNode,
    distortion: DistortionNode,
    mixer: MixerNode,
    panner: PannerNode,
    group: GroupNode,
    fmOperator: FmOperatorNode,
    wavetable: WavetableNode,
};

const EditorLayout = () => {
    const reactFlowWrapper = useRef(null);
    const [reactFlowInstance, setReactFlowInstance] = useState<ReactFlowInstance | null>(null);
    const [generatedCode, setGeneratedCode] = useState<string | null>(null);
    const [bpm, setBpm] = useState(120);
    const [isLooping, setIsLooping] = useState(false); // State for the loop toggle
    
    const {
        nodes,
        edges,
        setNodes,
        setEdges,
        selectedNode,
        selectedNodesForGrouping,
        isNamePromptVisible,
        setIsNamePromptVisible,
        onNodesChange,
        onEdgesChange,
        onConnect,
        updateNodeData,
        onDrop,
        onSelectionChange,
        handleUndo,
        handleRedo,
        handleCreateInstrument,
        handleInstrumentNameSubmit,
        handleCreateGroup,
    } = useGraphState();

    const { isPlaying, handlePlay, handleStop } = useAudioEngine(nodes, edges, isLooping, bpm);
    const { handleSave, handleLoad } = useFileIO(reactFlowInstance, setNodes, setEdges, () => {}, () => {}); 

    const handleGenerate = async () => {
        if (nodes.length === 0) {
            console.warn("Graph is empty. Add some nodes first.");
            return;
        }

        const formatNodesForCodegen = (nodeList: Node[]): any[] => {
            return nodeList.map(node => {
                let typeName = 'Unknown';
                let parameters: any = { ...node.data };
                let subgraph: any = null;

                delete parameters.label;

                switch (node.type) {
                    case 'lfo': typeName = 'LFO'; break;
                    case 'sampleHold': typeName = 'SampleHold'; break;
                    case 'oscillator': typeName = 'Oscillator'; break;
                    case 'filter': typeName = 'Filter'; break;
                    case 'noise': typeName = 'Noise'; break;
                    case 'adsr': typeName = 'ADSR'; break;
                    case 'delay': typeName = 'Delay'; break;
                    case 'reverb': typeName = 'Reverb'; break;
                    case 'distortion': typeName = 'Distortion'; break;
                    case 'mixer': typeName = 'Mixer'; break;
                    case 'panner': typeName = 'Panner'; break;
                    case 'fmOperator': typeName = 'FmOperator'; break;
                    case 'wavetable': typeName = 'Wavetable'; break;
                    case 'output': typeName = 'GraphOutput'; parameters = {}; break;
                    case 'instrument':
                    case 'group':
                        typeName = node.type === 'instrument' ? 'Instrument' : 'Group';
                        parameters = { name: node.data.name || node.data.label }; 
                        if (node.data.subgraph && node.data.subgraph.nodes) {
                            subgraph = {
                                nodes: formatNodesForCodegen(node.data.subgraph.nodes),
                                connections: node.data.subgraph.connections.map((edge: any) => ({
                                    from_node: parseInt(edge.from_node, 10),
                                    from_port: edge.from_port || 'output',
                                    to_node: parseInt(edge.to_node, 10),
                                    to_port: edge.to_port || 'input'
                                }))
                            };
                        }
                        break;
                    case 'InstrumentInput': typeName = 'GraphInput'; break;
                    case 'InstrumentOutput': typeName = 'GraphOutput'; break;
                }

                const result: any = {
                    id: parseInt(node.id, 10),
                    type: typeName,
                    position: node.position,
                    parameters: parameters,
                    exposed_parameters: node.data.exposedParameters || []
                };

                if (subgraph) {
                    result.subgraph = subgraph;
                }
                return result;
            });
        };

        const graphNodes = formatNodesForCodegen(nodes);

        const graphConnections = edges.map(edge => ({
            from_node: parseInt(edge.source, 10),
            from_port: edge.sourceHandle || 'output',
            to_node: parseInt(edge.target, 10),
            to_port: edge.targetHandle || 'input'
        }));

        const audioGraph = { nodes: graphNodes, connections: graphConnections };

        try {
            const code = await window.electron.invokeCodegen(JSON.stringify(audioGraph, null, 2));
            setGeneratedCode(code);
        } catch (error) {
            console.error("Error during code generation:", error);
            setGeneratedCode(`// ERROR: Failed to generate code.`);
        }
    };


    return (
        <div style={appContainerStyles}>
            {isNamePromptVisible && (
                <NamePromptModal
                    title="Create New Instrument"
                    defaultValue="MyInstrument"
                    onNameConfirm={handleInstrumentNameSubmit}
                    onCancel={() => setIsNamePromptVisible(false)}
                />
            )}
            <div style={sidebarPanelStyles}>
                <Sidebar 
                    onGenerate={handleGenerate} 
                    onPlay={handlePlay} 
                    onStop={handleStop} 
                    isPlaying={isPlaying}
                    onSave={handleSave}
                    onLoad={handleLoad}
                    onCreateInstrument={handleCreateInstrument}
                    onCreateGroup={handleCreateGroup}
                    canCreateInstrument={selectedNodesForGrouping.length > 0}
                    bpm={bpm}
                    onBpmChange={setBpm}
                    isLooping={isLooping}
                    onLoopToggle={() => setIsLooping(!isLooping)}
                />
            </div>
            <div style={mainCanvasStyles} ref={reactFlowWrapper}>
                <ReactFlow
                    nodes={nodes} 
                    edges={edges} 
                    nodeTypes={nodeTypes}
                    onNodesChange={onNodesChange} 
                    onEdgesChange={onEdgesChange}
                    onConnect={onConnect} 
                    onDragOver={(e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }}
                    onDrop={onDrop}
                    onSelectionChange={onSelectionChange}
                    onInit={setReactFlowInstance}
                    multiSelectionKeyCode={['Shift', 'Control']}
                    fitView
                >
                    <Background />
                    <Controls />
                </ReactFlow>
            </div>
            <div style={parameterPanelStyles}>
                {generatedCode ? (
                    <CodePreviewPanel code={generatedCode} onClose={() => setGeneratedCode(null)} />
                ) : (
                    <ParameterPanel 
                        selectedNode={selectedNode} 
                        onUpdateNode={updateNodeData}
                        allNodes={nodes}
                        allEdges={edges}
                        bpm={bpm}
                    />
                )}
            </div>
        </div>
    );
}

const App = () => (
    <ReactFlowProvider>
        <EditorLayout />
    </ReactFlowProvider>
);

export default App;


--- END FILE: app.tsx ---

--- START FILE: components/CodePreviewPanel.tsx ---

// src/components/CodePreviewPanel.tsx

import React, { useState } from 'react';

const panelStyles: React.CSSProperties = {
  padding: '15px',
  borderLeft: '1px solid #ddd',
  display: 'flex',
  flexDirection: 'column',
  height: '100%',
  boxSizing: 'border-box'
};

const preStyles: React.CSSProperties = {
    backgroundColor: '#2e2e2e',
    color: '#d4d4d4',
    padding: '10px',
    borderRadius: '4px',
    flexGrow: 1,
    overflow: 'auto',
    whiteSpace: 'pre-wrap',
    fontFamily: 'monospace'
}

const buttonContainerStyles: React.CSSProperties = {
    display: 'flex',
    gap: '10px',
    marginTop: '10px'
};

const baseButtonStyles: React.CSSProperties = {
    flexGrow: 1,
    padding: '10px',
    color: 'white',
    border: 'none',
    borderRadius: '5px',
    cursor: 'pointer',
    fontSize: '14px',
    transition: 'background-color 0.2s'
};

const copyButtonStyles: React.CSSProperties = {
    ...baseButtonStyles,
    backgroundColor: '#1971c2',
};

const closeButtonStyles: React.CSSProperties = {
    ...baseButtonStyles,
    backgroundColor: '#e03131',
};

interface CodePreviewProps {
    code: string;
    onClose: () => void;
}

const CodePreviewPanel: React.FC<CodePreviewProps> = ({ code, onClose }) => {
  const [isCopied, setIsCopied] = useState(false);

  const handleCopy = () => {
    navigator.clipboard.writeText(code).then(() => {
        setIsCopied(true);
        setTimeout(() => setIsCopied(false), 2000); // Reset button text after 2 seconds
    }).catch(err => {
        console.error('Failed to copy: ', err);
        alert('Failed to copy code to clipboard.');
    });
  };

  return (
    <div style={panelStyles}>
      <h2>Generated Code</h2>
      <pre style={preStyles}>
        <code>{code}</code>
      </pre>
      <div style={buttonContainerStyles}>
        <button style={copyButtonStyles} onClick={handleCopy} disabled={isCopied}>
            {isCopied ? 'Copied!' : 'Copy Code'}
        </button>
        <button style={closeButtonStyles} onClick={onClose}>Close</button>
      </div>
    </div>
  );
};

export default CodePreviewPanel;

--- END FILE: components/CodePreviewPanel.tsx ---

--- START FILE: components/InstrumentNode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

// This is a basic representation. We'll expand this later to dynamically
// render handles based on the instrument's subgraph.
const InstrumentNode = ({ data }: NodeProps) => {
  return (
    <div style={{
      background: '#2D3748', // A dark, slate-gray background
      border: '1px solid #4A5568',
      borderRadius: '8px',
      padding: '15px 25px',
      color: 'white',
      minWidth: '150px',
      textAlign: 'center',
      fontFamily: 'sans-serif',
    }}>
      {/* Input Handle - for gate, note, etc. */}
      <Handle
        type="target"
        position={Position.Left}
        id="input" // Generic input for now
        style={{ background: '#555' }}
      />

      <strong>{data.name || 'Instrument'}</strong>

      {/* Output Handle */}
      <Handle
        type="source"
        position={Position.Right}
        id="output" // Generic output
        style={{ background: '#555' }}
      />
    </div>
  );
};

export default memo(InstrumentNode);

--- END FILE: components/InstrumentNode.tsx ---

--- START FILE: components/NamePromptModal.tsx ---

import React, { useState } from 'react';

export const NamePromptModal = ({ onNameConfirm, onCancel }) => {
  const [name, setName] = useState('');

  const handleConfirm = () => {
    if (name.trim() !== '') {
      onNameConfirm(name);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
      <div className="bg-gray-800 p-6 rounded-lg shadow-lg text-white">
        <h3 className="text-lg font-bold mb-4">Create Instrument</h3>
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Enter instrument name"
          className="bg-gray-700 text-white w-full p-2 rounded mb-4"
          autoFocus
        />
        <div className="flex justify-end space-x-2">
            <button 
                onClick={onCancel}
                className="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded"
            >
                Cancel
            </button>
            <button 
                onClick={handleConfirm}
                className="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded"
            >
                Create
            </button>
        </div>
      </div>
    </div>
  );
};

export default NamePromptModal;


--- END FILE: components/NamePromptModal.tsx ---

--- START FILE: components/Nodes/ADSRNode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const adsrNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#fff3bf', borderColor: '#fcc419' };

const ADSRNodeComponent = ({ data }: NodeProps) => {
    return (
        <div style={adsrNodeStyles}>
            <Handle type="target" position={Position.Left} id="input" />
            <div><strong>{data.label || 'ADSR'}</strong></div>
            <Handle type="source" position={Position.Right} id="output" />
        </div>
    );
};

export const ADSRNode = memo(ADSRNodeComponent);

--- END FILE: components/Nodes/ADSRNode.tsx ---

--- START FILE: components/Nodes/DelayNode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const delayNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#fff9db', borderColor: '#f08c00' };

const DelayNodeComponent = ({ data }: NodeProps) => {
  return (
    <div style={delayNodeStyles}>
      <Handle type="target" position={Position.Left} id="input" />
      <div><strong>{data.label || 'Delay'}</strong></div>
      <Handle type="source" position={Position.Right} id="output" />
    </div>
  );
};

export const DelayNode = memo(DelayNodeComponent);

--- END FILE: components/Nodes/DelayNode.tsx ---

--- START FILE: components/Nodes/DistortionNode.tsx ---

// src/components/Nodes/DistortionNode.tsx
import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const distortionNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#ffc9c9', borderColor: '#e03131' };

const DistortionNodeComponent = ({ data }: NodeProps) => {
  return (
    <div style={distortionNodeStyles}>
      <Handle type="target" position={Position.Left} id="input" />
      <div><strong>{data.label || 'Distortion'}</strong></div>
      <Handle type="source" position={Position.Right} id="output" />
    </div>
  );
};

export const DistortionNode = memo(DistortionNodeComponent);


--- END FILE: components/Nodes/DistortionNode.tsx ---

--- START FILE: components/Nodes/FMOperatorNode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const nodeStyles: React.CSSProperties = {
    background: '#3E4A59',
    padding: '10px 20px',
    borderRadius: '8px',
    border: '1px solid #5A6A79',
    color: '#E0E0E0',
    textAlign: 'center',
    minWidth: '150px',
};

const labelStyles: React.CSSProperties = {
    display: 'block',
    marginBottom: '10px',
    fontWeight: 'bold',
    fontSize: '1.1em',
};

const handleStyle: React.CSSProperties = {
    width: '10px',
    height: '10px',
};

const handleLabelStyle: React.CSSProperties = {
    position: 'absolute',
    top: '-18px',
    fontSize: '10px',
    color: '#A0AEC0',
};

export const FmOperatorNode: React.FC<NodeProps> = ({ data }) => {
    return (
        <div style={nodeStyles}>
            <Handle
                type="target"
                position={Position.Top}
                id="input_mod"
                style={{ ...handleStyle, left: '25%' }}
            >
                <span style={{...handleLabelStyle, left: '-10px'}}>Mod</span>
            </Handle>
            <Handle
                type="target"
                position={Position.Top}
                id="input_carrier"
                style={{ ...handleStyle, left: '75%' }}
            >
                 <span style={{...handleLabelStyle, left: '-20px'}}>Carrier</span>
            </Handle>
            
            <label style={labelStyles}>{data.label || 'FM Operator'}</label>

            <Handle
                type="source"
                position={Position.Bottom}
                id="output"
                style={handleStyle}
            />
        </div>
    );
};

export default memo(FmOperatorNode);


--- END FILE: components/Nodes/FMOperatorNode.tsx ---

--- START FILE: components/Nodes/FilterNode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const filterNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#d0ebff' };

const FilterNodeComponent = ({ data }: NodeProps) => {
    return (
      <div style={filterNodeStyles}>
        <Handle type="target" position={Position.Left} id="input" />
        <div><strong>{data.label || 'Filter'}</strong></div>
        <Handle type="source" position={Position.Right} id="output" />
      </div>
    );
};

export const FilterNode = memo(FilterNodeComponent);

--- END FILE: components/Nodes/FilterNode.tsx ---

--- START FILE: components/Nodes/GraphOutputNode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const outputNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#ffe8cc', borderColor: '#e8590c' };

const GraphOutputNodeComponent = ({ data }: NodeProps) => {
    return (
      <div style={outputNodeStyles}>
        <Handle type="target" position={Position.Left} id="input" />
        <div><strong>{data.label || 'Output'}</strong></div>
      </div>
    );
};

export const GraphOutputNode = memo(GraphOutputNodeComponent);

--- END FILE: components/Nodes/GraphOutputNode.tsx ---

--- START FILE: components/Nodes/GroupNode.tsx ---

import React, { memo, useMemo } from 'react';
import { Handle, Position, NodeProps, useStore } from 'reactflow';

// This selector efficiently grabs the latest nodes and edges from the React Flow store.
// Using a selector is more performant than accessing the entire store object.
const allNodesAndEdgesSelector = (s) => ({
    nodes: s.nodes,
    edges: s.edges,
});

const groupNodeStyle: React.CSSProperties = {
    backgroundColor: 'rgba(45, 55, 72, 0.5)',
    border: '1px solid #718096',
    borderRadius: '8px',
    width: '100%',
    height: '100%',
    position: 'relative',
    color: 'white',
};

const groupNodeHeaderStyle: React.CSSProperties = {
    background: '#4A5568',
    padding: '8px',
    borderTopLeftRadius: '7px',
    borderTopRightRadius: '7px',
    fontWeight: 'bold',
};

const handleLabelStyle: React.CSSProperties = {
    position: 'absolute',
    top: '-8px',
    fontSize: '10px',
    color: '#A0AEC0',
    background: '#2D3748',
    padding: '1px 4px',
    borderRadius: '3px',
    whiteSpace: 'nowrap',
};

const leftHandleLabelStyle: React.CSSProperties = {
    ...handleLabelStyle,
    left: '18px',
};

const rightHandleLabelStyle: React.CSSProperties = {
    ...handleLabelStyle,
    right: '18px',
};

// Use a named export 'export const' instead of 'export default'
export const GroupNode: React.FC<NodeProps> = memo(({ id, data }) => {
    // We use the selector to get the latest nodes and edges from the store.
    // This ensures the component re-renders when connections change.
    const { nodes: allNodes, edges: allEdges } = useStore(allNodesAndEdgesSelector);

    // Memoize the calculation of child nodes to avoid re-computation on every render.
    // ADDED a fallback to an empty array `|| []` to prevent crash on initial render.
    const childNodeIds = useMemo(() => 
        (allNodes || []).filter(n => n.parentNode === id).map(n => n.id), 
    [allNodes, id]);

    // This is the core logic for "Intelligent I/O".
    // It inspects all edges to determine which should create a handle on the group.
    const { inputs, outputs } = useMemo(() => {
        const inputs = new Map();
        const outputs = new Map();

        // ADDED defensive checks. If nodes or edges aren't available yet, return empty handles.
        if (!allNodes || !allEdges) {
            return { inputs: [], outputs: [] };
        }

        allEdges.forEach(edge => {
            const isTargetInGroup = childNodeIds.includes(edge.target);
            const isSourceInGroup = childNodeIds.includes(edge.source);

            // An edge from outside to inside means we need an INPUT handle on the group.
            if (!isSourceInGroup && isTargetInGroup) {
                const targetNode = allNodes.find(n => n.id === edge.target);
                // Create a unique but stable ID for the handle.
                const handleId = `group-input-${edge.target}-${edge.targetHandle || 'default'}`;
                if (!inputs.has(handleId)) {
                    inputs.set(handleId, {
                        id: handleId,
                        label: `${targetNode?.data.label || targetNode?.type} -> ${edge.targetHandle || 'input'}`,
                    });
                }
            }
            
            // An edge from inside to outside means we need an OUTPUT handle on the group.
            if (isSourceInGroup && !isTargetInGroup) {
                const sourceNode = allNodes.find(n => n.id === edge.source);
                const handleId = `group-output-${edge.source}-${edge.sourceHandle || 'default'}`;
                if (!outputs.has(handleId)) {
                    outputs.set(handleId, {
                        id: handleId,
                        label: `${sourceNode?.data.label || sourceNode?.type} -> ${edge.sourceHandle || 'output'}`,
                    });
                }
            }
        });

        return { inputs: Array.from(inputs.values()), outputs: Array.from(outputs.values()) };
    }, [allEdges, childNodeIds, allNodes]);


    return (
        <div style={groupNodeStyle}>
            <div style={groupNodeHeaderStyle}>
                {data.label || 'Group'}
            </div>
            
            {/* Dynamically render input handles based on the calculated connections */}
            {inputs.map((input, index) => (
                <Handle
                    key={input.id}
                    type="target"
                    position={Position.Left}
                    id={input.id}
                    style={{ top: `${(index + 1) * 35 + 20}px`, background: '#4A5568', borderColor: '#A0AEC0' }}
                >
                   <div style={leftHandleLabelStyle}>{input.label}</div>
                </Handle>
            ))}

            {/* Dynamically render output handles */}
            {outputs.map((output, index) => (
                <Handle
                    key={output.id}
                    type="source"
                    position={Position.Right}
                    id={output.id}
                    style={{ top: `${(index + 1) * 35 + 20}px`, background: '#4A5568', borderColor: '#A0AEC0' }}
                >
                    <div style={rightHandleLabelStyle}>{output.label}</div>
                </Handle>
            ))}
        </div>
    );
});

--- END FILE: components/Nodes/GroupNode.tsx ---

--- START FILE: components/Nodes/LFONode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const lfoNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#f3d9fa', borderColor: '#be4bdb' };

const LFONodeComponent = ({ data }: NodeProps) => {
    return (
        <div style={lfoNodeStyles}>
            <div><strong>{data.label || 'LFO'}</strong></div>
            <Handle type="source" position={Position.Right} id="output" />
        </div>
    );
};

export const LFONode = memo(LFONodeComponent);

--- END FILE: components/Nodes/LFONode.tsx ---

--- START FILE: components/Nodes/MixerNode.tsx ---

// src/components/Nodes/MixerNode.tsx
import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const mixerNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#e9ecef', borderColor: '#868e96' };

const MixerNodeComponent = ({ data }: NodeProps) => {
  const numInputs = data.inputCount || 4; // Default to 4 inputs if not specified
  const handles = [];
  for (let i = 1; i <= numInputs; i++) {
    handles.push( 
      <Handle 
        key={`input_${i}`}
        type="target" 
        position={Position.Left} 
        id={`input_${i}`} 
        style={{ top: `${(i / (numInputs + 1)) * 100}%` }} 
      />
    );
  }

  return (
    <div style={mixerNodeStyles}>
      {handles}
      <div><strong>{data.label || 'Mixer'}</strong></div>
      <Handle type="source" position={Position.Right} id="output" />
    </div>
  );
};

export const MixerNode = memo(MixerNodeComponent);


--- END FILE: components/Nodes/MixerNode.tsx ---

--- START FILE: components/Nodes/NoiseNode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const noiseNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#e9ecef', borderColor: '#495057' };

const NoiseNodeComponent = ({ data }: NodeProps) => {
    return (
        <div style={noiseNodeStyles}>
            <div><strong>{data.label || 'Noise'}</strong></div>
            <Handle type="source" position={Position.Right} id="output" />
        </div>
    );
};

export const NoiseNode = memo(NoiseNodeComponent);

--- END FILE: components/Nodes/NoiseNode.tsx ---

--- START FILE: components/Nodes/OscillatorNode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const oscillatorNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#e6fcf5', borderColor: '#2f9e44' };

const OscillatorNodeComponent: React.FC<NodeProps> = ({ data }) => {
    return (
        <div style={oscillatorNodeStyles}>
            <Handle type="target" position={Position.Left} id="input_freq" style={{ top: '33%' }} />
            <Handle type="target" position={Position.Left} id="input_amp" style={{ top: '66%' }} />
            <div><strong>{data.label || 'Oscillator'}</strong></div>
            <Handle type="source" position={Position.Right} id="output" />
        </div>
    );
};

export const OscillatorNode = memo(OscillatorNodeComponent);


--- END FILE: components/Nodes/OscillatorNode.tsx ---

--- START FILE: components/Nodes/PannerNode.tsx ---

// src/components/Nodes/PannerNode.tsx
import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const pannerNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#e7f5ff', borderColor: '#74c0fc' };

const PannerNodeComponent = ({ data }: NodeProps) => {
  return (
    <div style={pannerNodeStyles}>
      <Handle type="target" position={Position.Left} id="input" />
      <div><strong>{data.label || 'Panner'}</strong></div>
      <Handle type="source" position={Position.Right} id="output" />
    </div>
  );
};

export const PannerNode = memo(PannerNodeComponent);


--- END FILE: components/Nodes/PannerNode.tsx ---

--- START FILE: components/Nodes/ReverbNode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const reverbNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#dbe4ff', borderColor: '#4c6ef5' };

const ReverbNodeComponent = ({ data }: NodeProps) => {
  return (
    <div style={reverbNodeStyles}>
      <Handle type="target" position={Position.Left} id="input" />
      <div><strong>{data.label || 'Reverb'}</strong></div>
      <Handle type="source" position={Position.Right} id="output" />
    </div>
  );
};

export const ReverbNode = memo(ReverbNodeComponent);

--- END FILE: components/Nodes/ReverbNode.tsx ---

--- START FILE: components/Nodes/SampleHoldNode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const baseNodeStyles: React.CSSProperties = {
    border: '1px solid #2f9e44',
    borderRadius: '4px',
    padding: '10px 15px',
    width: 150,
    textAlign: 'center'
};

const sampleHoldNodeStyles: React.CSSProperties = { ...baseNodeStyles, background: '#f3d9fa', borderColor: '#be4bdb' };

const SampleHoldNodeComponent = ({ data }: NodeProps) => {
    return (
        <div style={sampleHoldNodeStyles}>
            <div><strong>{data.label || 'Sample & Hold'}</strong></div>
            <Handle type="source" position={Position.Right} id="output" />
        </div>
    );
};

export const SampleHoldNode = memo(SampleHoldNodeComponent);

--- END FILE: components/Nodes/SampleHoldNode.tsx ---

--- START FILE: components/Nodes/WavetableNode.tsx ---

import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

const nodeStyles: React.CSSProperties = {
    background: '#593E59',
    padding: '10px 20px',
    borderRadius: '8px',
    border: '1px solid #795A79',
    color: '#E0E0E0',
    textAlign: 'center',
    minWidth: '150px',
};

const labelStyles: React.CSSProperties = {
    display: 'block',
    marginBottom: '10px',
    fontWeight: 'bold',
    fontSize: '1.1em',
};

const handleStyle: React.CSSProperties = {
    width: '10px',
    height: '10px',
};

const handleLabelStyle: React.CSSProperties = {
    position: 'absolute',
    top: '-18px',
    fontSize: '10px',
    color: '#A0AEC0',
};


export const WavetableNode: React.FC<NodeProps> = ({ data }) => {
    return (
        <div style={nodeStyles}>
            <Handle
                type="target"
                position={Position.Top}
                id="input_freq"
                style={{ ...handleStyle, left: '25%' }}
            >
                 <span style={{...handleLabelStyle, left: '-10px'}}>Freq</span>
            </Handle>
             <Handle
                type="target"
                position={Position.Top}
                id="input_pos"
                style={{ ...handleStyle, left: '75%' }}
            >
                 <span style={{...handleLabelStyle, left: '-20px'}}>Position</span>
            </Handle>
            
            <label style={labelStyles}>{data.label || 'Wavetable'}</label>
            
            <Handle
                type="source"
                position={Position.Bottom}
                id="output"
                style={handleStyle}
            />
        </div>
    );
};

export default memo(WavetableNode);


--- END FILE: components/Nodes/WavetableNode.tsx ---

--- START FILE: components/Nodes/index.ts ---

export * from './OscillatorNode';
export * from './FilterNode';
export * from './GraphOutputNode';
export * from './NoiseNode';
export * from './ADSRNode';
export * from './LFONode';
export * from './SampleHoldNode';
export * from './DelayNode';
export * from './ReverbNode';
export * from './DistortionNode';
export * from './MixerNode';
export * from './PannerNode';
export * from './GroupNode';
export * from './FmOperatorNode';
export * from './WavetableNode';

--- END FILE: components/Nodes/index.ts ---

--- START FILE: components/ParameterPanel.tsx ---

import React from 'react';
import { Node, Edge } from 'reactflow';
import { CustomSlider } from './controls/CustomSlider';
import { BpmSyncControl } from './controls/BpmSyncControl';
import { AdsrEnvelopeEditor } from './controls/AdsrEnvelopeEditor';
import { XYPad } from './controls/XYPad';

// --- STYLES ---
const panelStyles: React.CSSProperties = {
    padding: '15px',
    fontFamily: 'sans-serif',
    color: '#E0E0E0',
    background: '#2D2D2D',
    height: '100%',
    boxSizing: 'border-box',
    overflowY: 'auto',
};

const headerStyles: React.CSSProperties = {
    borderBottom: '1px solid #444',
    paddingBottom: '10px',
    marginBottom: '15px',
}

const subHeaderStyles: React.CSSProperties = {
    borderBottom: '1px solid #444',
    paddingBottom: '5px',
    marginBottom: '10px',
    marginTop: '20px',
    fontSize: '0.9em',
    color: '#a0aec0'
}

const inputGroupStyles: React.CSSProperties = {
    marginBottom: '15px',
};

const labelContainerStyles: React.CSSProperties = {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: '5px',
}

const labelStyles: React.CSSProperties = {
    fontWeight: 'bold',
    color: '#CCCCCC'
};

const inputStyles: React.CSSProperties = {
    width: '100%',
    padding: '8px',
    boxSizing: 'border-box',
    borderRadius: '4px',
    border: '1px solid #555',
    background: '#333',
    color: '#E0E0E0',
    outline: 'none',
};

const iconButtonStyles: React.CSSProperties = {
    background: 'none',
    border: 'none',
    cursor: 'pointer',
    padding: '0 4px',
};

// --- ICONS (as inline SVG components) ---

const LinkIcon: React.FC<{ isExposed: boolean }> = ({ isExposed }) => (
    <svg 
        xmlns="http://www.w3.org/2000/svg" 
        width="18" 
        height="18" 
        viewBox="0 0 24 24" 
        fill="none" 
        stroke={isExposed ? '#22A5F1' : '#777'}
        strokeWidth="2" 
        strokeLinecap="round" 
        strokeLinejoin="round"
        style={{ transition: 'stroke 0.2s ease-in-out' }}
    >
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
    </svg>
);


// --- PROPS INTERFACE ---

interface ParameterPanelProps {
    selectedNode: Node | null;
    onUpdateNode: (nodeId: string, data: object, subNodeId?: string) => void;
    allNodes: Node[];
    allEdges: Edge[];
    bpm: number;
}


// --- MAIN COMPONENT ---

const ParameterPanel: React.FC<ParameterPanelProps> = ({ selectedNode, onUpdateNode, allNodes, bpm }) => {

    if (!selectedNode) {
        return <div style={panelStyles}><p>Select a node to edit its parameters.</p></div>;
    }

    // --- EVENT HANDLERS ---

    const handleParameterChange = (paramName: string, value: any, subNodeId?: string) => {
        const dataToUpdate = typeof value === 'object' && !Array.isArray(value) 
            ? value 
            : { [paramName]: value };
        
        if (subNodeId) {
            const subNode = allNodes.find(n => n.id === subNodeId) || selectedNode.data.subgraph?.nodes.find(n => n.id === subNodeId);
            if (!subNode) return;
            const newData = { ...subNode.data, ...dataToUpdate };
            onUpdateNode(selectedNode.id, newData, subNodeId);
            return;
        }

        const newData = { ...selectedNode.data, ...dataToUpdate };
        onUpdateNode(selectedNode.id, newData);
    };

    const handleGenericChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>, subNodeId?: string) => {
        const { name, value, type } = e.target;
        let parsedValue: string | number | boolean = value;

        if (type === 'checkbox') {
            parsedValue = (e.target as HTMLInputElement).checked;
        } else if (type === 'number' || type === 'range') {
            parsedValue = parseFloat(value);
        }
        handleParameterChange(name, parsedValue, subNodeId);
    };

    const toggleParameterExposure = (paramKey: string, subNodeId?: string) => {
        const nodeIdToUpdate = subNodeId || selectedNode.id;
        const nodeToUpdate = allNodes.find(n => n.id === nodeIdToUpdate) || selectedNode.data.subgraph?.nodes.find(n => n.id === nodeIdToUpdate);
        if(!nodeToUpdate) return;

        const currentExposed: string[] = nodeToUpdate.data.exposedParameters || [];
        const isExposed = currentExposed.includes(paramKey);
        
        const newExposed = isExposed
            ? currentExposed.filter(p => p !== paramKey)
            : [...currentExposed, paramKey];

        const newData = { ...nodeToUpdate.data, exposedParameters: newExposed };
        onUpdateNode(selectedNode.id, newData, subNodeId);
    };


    // --- RENDER HELPERS ---

    const renderParameterControl = (
        paramKey: string, 
        label: string, 
        children: React.ReactNode, 
        isExposable: boolean = true,
        isExposed: boolean = false,
        onToggle: () => void
    ) => {
        return (
            <div style={inputGroupStyles} key={paramKey}>
                <div style={labelContainerStyles}>
                    <label style={labelStyles}>{label}</label>
                    {isExposable && (
                         <button 
                            style={iconButtonStyles} 
                            onClick={onToggle}
                            title={isExposed ? `Un-expose "${label}"` : `Expose "${label}" to public API`}
                         >
                            <LinkIcon isExposed={isExposed} />
                        </button>
                    )}
                </div>
                {children}
            </div>
        );
    };

    const renderBpmSyncToggle = (node: Node, subNodeId?: string) => {
        const { data } = node;
        const isBpmSyncExposed = data.exposedParameters?.includes('bpmSync') || false;
        const uniqueId = `bpmSyncCheckbox-${subNodeId || node.id}`;

        return (
             <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
                <label htmlFor={uniqueId} style={{...labelStyles, cursor: 'pointer'}}>
                    BPM Sync
                </label>
                <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                    <input
                        id={uniqueId}
                        type="checkbox"
                        name="bpmSync"
                        checked={data.bpmSync || false}
                        onChange={(e) => handleGenericChange(e, subNodeId || node.id)}
                        style={{ height: '18px', width: '18px', cursor: 'pointer' }}
                    />
                    <button
                        style={iconButtonStyles}
                        onClick={() => toggleParameterExposure('bpmSync', subNodeId || node.id)}
                        title={isBpmSyncExposed ? 'Un-expose "BPM Sync"' : 'Expose "BPM Sync" to public API'}
                    >
                        <LinkIcon isExposed={isBpmSyncExposed} />
                    </button>
                </div>
            </div>
        );
    };

    const renderNodeParameters = (node: Node, subNodeId?: string) => {
        const { type, data } = node;
        
        const createControl = (paramKey: string, label: string, children: React.ReactNode, isExposable: boolean = true) => {
            const isExposed = data.exposedParameters?.includes(paramKey) || false;
            return renderParameterControl(paramKey, label, children, isExposable, isExposed, () => toggleParameterExposure(paramKey, subNodeId || node.id));
        };
        
        const createSelect = (paramKey: string, options: string[]) => (
            <select name={paramKey} value={data[paramKey]} onChange={(e) => handleGenericChange(e, subNodeId || node.id)} style={inputStyles}>
                {options.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
        );

        switch (type) {
            case 'adsr':
                return ( <>
                    <AdsrEnvelopeEditor 
                        value={{ attack: data.attack, decay: data.decay, sustain: data.sustain, release: data.release }}
                        onChange={(newAdsr) => handleParameterChange('adsr', newAdsr, subNodeId || node.id)}
                    />
                    {createControl('amount', 'Amount/Depth', 
                        <CustomSlider min={0} max={1} value={data.amount ?? 1} onChange={val => handleParameterChange('amount', val, subNodeId || node.id)} />
                    )}
                    {createControl('velocitySensitivity', 'Velocity Sens.', 
                        <CustomSlider min={0} max={1} value={data.velocitySensitivity ?? 0.5} onChange={val => handleParameterChange('velocitySensitivity', val, subNodeId || node.id)} />
                    )}
                </> );
            case 'filter':
                return ( <>
                    {createControl('type', 'Filter Type', createSelect('type', ['Lowpass', 'Highpass', 'Bandpass', 'Notch']), false )}
                    <XYPad
                        xValue={data.cutoff}
                        yValue={data.resonance}
                        minX={20}
                        maxX={20000}
                        minY={0.1}
                        maxY={30}
                        onChange={({x, y}) => handleParameterChange('filter', { cutoff: x, resonance: y }, subNodeId || node.id)}
                        xScale="log"
                        yScale="log"
                    />
                    <div>Cutoff: {(data.cutoff ?? 1000).toFixed(2)} Hz</div>
                    <div>Resonance: {(data.resonance ?? 1).toFixed(2)}</div>
                </> );
            case 'lfo':
                return ( <>
                    {createControl('waveform', 'Waveform', createSelect('waveform', ['Sine', 'Sawtooth', 'Triangle', 'Square']), false )}
                    
                    {data.bpmSync 
                        ? createControl('syncRate', 'Sync Rate', 
                            <BpmSyncControl value={data.syncRate ?? '1/4'} onChange={val => handleParameterChange('syncRate', val, subNodeId || node.id)} />
                          )
                        : createControl('frequency', 'Frequency (Hz)', 
                            <CustomSlider min={0.1} max={50} value={data.frequency ?? 5} onChange={val => handleParameterChange('frequency', val, subNodeId || node.id)} scale="log" />
                          )
                    }

                    {createControl('amplitude', 'Amplitude (Depth)', 
                        <CustomSlider min={0} max={1} value={data.amplitude ?? 1} onChange={val => handleParameterChange('amplitude', val, subNodeId || node.id)} />
                    )}
                    {renderBpmSyncToggle(node, subNodeId)}
                </> );
            case 'delay':
                return ( <>
                    {data.bpmSync 
                        ? createControl('syncRate', 'Sync Rate', 
                            <BpmSyncControl value={data.syncRate ?? '1/8'} onChange={val => handleParameterChange('syncRate', val, subNodeId || node.id)} />
                          )
                        : createControl('delayTime', 'Delay Time (s)', 
                            <CustomSlider min={0.001} max={5} value={data.delayTime ?? 0.5} onChange={val => handleParameterChange('delayTime', val, subNodeId || node.id)} />
                          )
                    }

                    {createControl('feedback', 'Feedback', 
                        <CustomSlider min={0} max={1} value={data.feedback ?? 0.5} onChange={val => handleParameterChange('feedback', val, subNodeId || node.id)} />
                    )}
                    {createControl('mix', 'Wet/Dry Mix', 
                        <CustomSlider min={0} max={1} value={data.mix ?? 0.5} onChange={val => handleParameterChange('mix', val, subNodeId || node.id)} />
                    )}
                    {renderBpmSyncToggle(node, subNodeId)}
                </> );
            case 'sampleHold':
                 return ( <>
                    {data.bpmSync 
                        ? createControl('syncRate', 'Sync Rate', 
                            <BpmSyncControl value={data.syncRate ?? '1/8'} onChange={val => handleParameterChange('syncRate', val, subNodeId || node.id)} />
                          )
                        : createControl('rate', 'Rate (Hz)', 
                            <CustomSlider min={0.1} max={50} value={data.rate ?? 10} onChange={val => handleParameterChange('rate', val, subNodeId || node.id)} scale="log" />
                          )
                    }
                    {createControl('amplitude', 'Amplitude (Depth)', 
                        <CustomSlider min={0} max={1} value={data.amplitude ?? 1} onChange={val => handleParameterChange('amplitude', val, subNodeId || node.id)} />
                    )}
                    {renderBpmSyncToggle(node, subNodeId)}
                </> );
            case 'fmOperator':
                return ( <>
                    {createControl('frequency', 'Carrier Freq (Hz)', 
                        <CustomSlider min={20} max={20000} value={data.frequency ?? 440} onChange={val => handleParameterChange('frequency', val, subNodeId || node.id)} scale="log" />
                    )}
                    {createControl('modIndex', 'Modulation Index', 
                        <CustomSlider min={0} max={1000} value={data.modIndex ?? 100} onChange={val => handleParameterChange('modIndex', val, subNodeId || node.id)} />
                    )}
                </> );
            case 'wavetable':
                return ( <>
                    {createControl('tableName', 'Table', createSelect('tableName', ['Sine', 'Triangle', 'Sawtooth', 'Square']), false )}
                    {createControl('frequency', 'Frequency (Hz)', 
                        <CustomSlider min={20} max={20000} value={data.frequency ?? 440} onChange={val => handleParameterChange('frequency', val, subNodeId || node.id)} scale="log" />
                    )}
                    {createControl('position', 'Table Position', 
                        <CustomSlider min={0} max={3} value={data.position ?? 0} onChange={val => handleParameterChange('position', val, subNodeId || node.id)} step={0.01} />
                    )}
                </> );
            case 'oscillator':
                return ( <>
                    {createControl('waveform', 'Waveform', createSelect('waveform', ['Sawtooth', 'Sine', 'Triangle', 'Square']), false )}
                    {createControl('frequency', 'Frequency (Hz)', 
                        <CustomSlider min={20} max={20000} value={data.frequency ?? 440} onChange={val => handleParameterChange('frequency', val, subNodeId || node.id)} scale="log" />
                    )}
                    {createControl('amplitude', 'Amplitude', 
                        <CustomSlider min={0} max={1} value={data.amplitude ?? 0.5} onChange={val => handleParameterChange('amplitude', val, subNodeId || node.id)} />
                    )}
                    {data.waveform === 'Square' && createControl('pulseWidth', 'Pulse Width', 
                        <CustomSlider min={0.01} max={0.99} value={data.pulseWidth ?? 0.5} onChange={val => handleParameterChange('pulseWidth', val, subNodeId || node.id)} />
                    )}
                    {createControl('phase', 'Phase', 
                        <CustomSlider min={0} max={360} value={data.phase ?? 0} onChange={val => handleParameterChange('phase', val, subNodeId || node.id)} />
                    )}
                </> );
            case 'noise':
                return ( <>
                    {createControl('type', 'Noise Type', createSelect('type', ['White', 'Pink']), false )}
                    {createControl('amplitude', 'Amplitude', 
                        <CustomSlider min={0} max={1} value={data.amplitude ?? 1} onChange={val => handleParameterChange('amplitude', val, subNodeId || node.id)} />
                    )}
                </> );
            case 'reverb':
                return ( <>
                    {createControl('decay', 'Decay (s)', 
                        <CustomSlider min={0.1} max={10} value={data.decay ?? 3} onChange={val => handleParameterChange('decay', val, subNodeId || node.id)} />
                    )}
                    {createControl('preDelay', 'Pre-Delay (s)', 
                        <CustomSlider min={0} max={1} value={data.preDelay ?? 0.01} onChange={val => handleParameterChange('preDelay', val, subNodeId || node.id)} />
                    )}
                    {createControl('mix', 'Wet/Dry Mix', 
                        <CustomSlider min={0} max={1} value={data.mix ?? 0.5} onChange={val => handleParameterChange('mix', val, subNodeId || node.id)} />
                    )}
                </> );
            case 'distortion':
                return ( <>
                    {createControl('drive', 'Drive', 
                        <CustomSlider min={1} max={100} value={data.drive ?? 20} onChange={val => handleParameterChange('drive', val, subNodeId || node.id)} />
                    )}
                    {createControl('tone', 'Tone (Hz)', 
                        <CustomSlider min={100} max={10000} value={data.tone ?? 4000} onChange={val => handleParameterChange('tone', val, subNodeId || node.id)} scale="log" />
                    )}
                    {createControl('mix', 'Wet/Dry Mix', 
                        <CustomSlider min={0} max={1} value={data.mix ?? 0.5} onChange={val => handleParameterChange('mix', val, subNodeId || node.id)} />
                    )}
                </> );
            case 'mixer':
                const inputCount = data.inputCount || 4;
                const mixerControls = [];
                for (let i = 1; i <= inputCount; i++) {
                    const paramKey = `level${i}`;
                    mixerControls.push(
                        createControl(paramKey, `Input ${i} Level`,
                            <CustomSlider min={0} max={1} value={data[paramKey] ?? 0.75} onChange={val => handleParameterChange(paramKey, val, subNodeId || node.id)} />
                        , true)
                    );
                }
                return <>{mixerControls}</>;
            case 'panner':
                return ( <>
                    {createControl('pan', 'Pan', 
                        <CustomSlider min={-1} max={1} value={data.pan ?? 0} onChange={val => handleParameterChange('pan', val, subNodeId || node.id)} />
                    )}
                </> );
            case 'instrument':
                return ( <>
                    {createControl('name', 'Instrument Name', 
                         <input type="text" name="name" value={data.name} onChange={(e) => handleGenericChange(e, subNodeId || node.id)} style={inputStyles} />, false
                    )}
                    <h4 style={subHeaderStyles}>Polyphony</h4>
                    {createControl('voiceCount', 'Voice Count', 
                        <CustomSlider min={1} max={32} step={1} value={data.voiceCount ?? 8} onChange={val => handleParameterChange('voiceCount', val, subNodeId || node.id)} />
                    )}
                    {createControl('glide', 'Glide (s)', 
                        <CustomSlider min={0} max={2} value={data.glide ?? 0.05} onChange={val => handleParameterChange('glide', val, subNodeId || node.id)} />
                    )}
                    <h4 style={subHeaderStyles}>Unison</h4>
                    {createControl('unison', 'Unison Voices', 
                        <CustomSlider min={1} max={16} step={1} value={data.unison ?? 1} onChange={val => handleParameterChange('unison', val, subNodeId || node.id)} />
                    )}
                    {createControl('detune', 'Detune (cents)', 
                        <CustomSlider min={0} max={100} value={data.detune ?? 5} onChange={val => handleParameterChange('detune', val, subNodeId || node.id)} />
                    )}
                    <h4 style={subHeaderStyles}>Internal Nodes</h4>
                    {data.subgraph?.nodes.map((subNode: Node) => (
                        <div key={subNode.id}>
                            <h4 style={subHeaderStyles}>{subNode.data.label || subNode.type}</h4>
                            {renderNodeParameters(subNode, subNode.id)}
                        </div>
                    ))}
                </> );
            case 'group':
                 const childNodes = allNodes.filter(n => n.parentNode === node.id);
                 return (
                     <>
                         {createControl('label', 'Group Name', 
                            <input type="text" name="label" value={data.label} onChange={(e) => handleGenericChange(e, subNodeId || node.id)} style={inputStyles} />, false
                         )}
                         {childNodes.map((subNode: Node) => (
                             <div key={subNode.id}>
                                 <h4 style={subHeaderStyles}>{subNode.data.label || subNode.type}</h4>
                                 {renderNodeParameters(subNode, subNode.id)}
                             </div>
                         ))}
                     </>
                 );
            default:
                return <p>This node has no configurable parameters.</p>;
        }
    };

    return (
        <div style={panelStyles}>
            <div style={headerStyles}>
                <h3>{selectedNode.data.label || selectedNode.type}</h3>
            </div>
            {renderNodeParameters(selectedNode)}
        </div>
    );
};

export default ParameterPanel;


--- END FILE: components/ParameterPanel.tsx ---

--- START FILE: components/Sidebar.tsx ---

import React from 'react';

// --- STYLES ---

const sidebarStyles: React.CSSProperties = {
    padding: '15px',
    fontFamily: 'sans-serif',
    color: '#E0E0E0',
    height: '100%',
    boxSizing: 'border-box',
    overflowY: 'auto',
};

const titleStyles: React.CSSProperties = {
    fontSize: '1.5em',
    fontWeight: 'bold',
    marginBottom: '20px',
    textAlign: 'center',
    color: '#FFFFFF',
};

const sectionTitleStyles: React.CSSProperties = {
    fontSize: '1.1em',
    fontWeight: '600',
    marginTop: '20px',
    marginBottom: '10px',
    color: '#a0aec0',
    borderBottom: '1px solid #4A5568',
    paddingBottom: '5px',
};

const nodeStyles: React.CSSProperties = {
    padding: '10px',
    marginBottom: '10px',
    borderRadius: '5px',
    background: '#384252',
    border: '1px solid #4A5568',
    cursor: 'grab',
    textAlign: 'center',
};

const buttonStyles: React.CSSProperties = {
    width: '100%',
    padding: '10px',
    borderRadius: '5px',
    border: 'none',
    color: 'white',
    fontWeight: 'bold',
    cursor: 'pointer',
    marginTop: '5px',
    transition: 'background-color 0.2s',
};

const primaryButtonStyles: React.CSSProperties = {
    ...buttonStyles,
    background: '#3182CE',
};

const secondaryButtonStyles: React.CSSProperties = {
    ...buttonStyles,
    background: '#4A5568',
};

const activeLoopButtonStyles: React.CSSProperties = {
    ...buttonStyles,
    background: '#2F855A', // A green color to indicate it's active
};

const disabledButtonStyles: React.CSSProperties = {
    ...buttonStyles,
    background: '#4A5568',
    opacity: 0.5,
    cursor: 'not-allowed',
};

const bpmInputStyles: React.CSSProperties = {
    width: '100%',
    padding: '8px',
    boxSizing: 'border-box',
    borderRadius: '4px',
    border: '1px solid #555',
    background: '#333',
    color: '#E0E0E0',
    outline: 'none',
    textAlign: 'center',
    fontSize: '1.2em',
};

// --- PROPS INTERFACE ---

interface SidebarProps {
    onGenerate: () => void;
    onPlay: () => void;
    onStop: () => void;
    isPlaying: boolean;
    onSave: () => void;
    onLoad: () => void;
    onCreateInstrument: () => void;
    onCreateGroup: () => void;
    canCreateInstrument: boolean;
    bpm: number;
    onBpmChange: (newBpm: number) => void;
    isLooping: boolean;
    onLoopToggle: () => void;
}


// --- MAIN COMPONENT ---

const Sidebar: React.FC<SidebarProps> = ({ 
    onGenerate, 
    onPlay, 
    onStop, 
    isPlaying,
    onSave,
    onLoad,
    onCreateInstrument,
    onCreateGroup,
    canCreateInstrument,
    bpm,
    onBpmChange,
    isLooping,
    onLoopToggle,
}) => {

    const onDragStart = (event: React.DragEvent, nodeType: string) => {
        event.dataTransfer.setData('application/reactflow', nodeType);
        event.dataTransfer.effectAllowed = 'move';
    };

    return (
        <div style={sidebarStyles}>
            <h1 style={titleStyles}>Skald</h1>

            <div>
                <h2 style={sectionTitleStyles}>Global</h2>
                <label style={{display: 'block', textAlign: 'center', marginBottom: '5px'}}>BPM</label>
                <input 
                    type="number" 
                    value={bpm} 
                    onChange={(e) => onBpmChange(parseInt(e.target.value, 10))}
                    style={bpmInputStyles}
                    min="20"
                    max="300"
                />
            </div>

            <div>
                <h2 style={sectionTitleStyles}>Graph Actions</h2>
                <button style={primaryButtonStyles} onClick={onGenerate}>Generate</button>
                {!isPlaying ? (
                    <button style={secondaryButtonStyles} onClick={onPlay}>Play</button>
                ) : (
                    <button style={{...secondaryButtonStyles, background: '#C53030'}} onClick={onStop}>Stop</button>
                )}
                <button 
                    style={isLooping ? activeLoopButtonStyles : secondaryButtonStyles} 
                    onClick={onLoopToggle}
                >
                    {isLooping ? 'Looping' : 'Loop'}
                </button>
                <button style={secondaryButtonStyles} onClick={onSave}>Save</button>
                <button style={secondaryButtonStyles} onClick={onLoad}>Load</button>
            </div>

            <div>
                <h2 style={sectionTitleStyles}>Grouping</h2>
                <button 
                    style={canCreateInstrument ? secondaryButtonStyles : disabledButtonStyles} 
                    onClick={onCreateInstrument}
                    disabled={!canCreateInstrument}
                    title={canCreateInstrument ? "Group selected nodes into a reusable instrument" : "Select 2 or more nodes to create an instrument"}
                >
                    Create Instrument
                </button>
                <button 
                    style={canCreateInstrument ? secondaryButtonStyles : disabledButtonStyles} 
                    onClick={onCreateGroup}
                    disabled={!canCreateInstrument}
                    title={canCreateInstrument ? "Group selected nodes visually" : "Select 2 or more nodes to create a group"}
                >
                    Create Group
                </button>
            </div>

            <div>
                <h2 style={sectionTitleStyles}>Nodes</h2>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'oscillator')} draggable>Oscillator</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'noise')} draggable>Noise</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'lfo')} draggable>LFO</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'sampleHold')} draggable>S & H</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'fmOperator')} draggable>FM Operator</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'wavetable')} draggable>Wavetable</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'adsr')} draggable>ADSR</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'filter')} draggable>Filter</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'delay')} draggable>Delay</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'reverb')} draggable>Reverb</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'distortion')} draggable>Distortion</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'mixer')} draggable>Mixer</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'panner')} draggable>Panner</div>
                <div style={nodeStyles} onDragStart={(event) => onDragStart(event, 'output')} draggable>Output</div>
            </div>
        </div>
    );
};

export default Sidebar;


--- END FILE: components/Sidebar.tsx ---

--- START FILE: components/controls/AdsrEnvelopeEditor.tsx ---

import React, { useState, useRef, useCallback, useEffect } from 'react';

// --- PROPS INTERFACE ---

interface AdsrData {
    attack: number;
    decay: number;
    sustain: number;
    release: number;
}

interface AdsrEnvelopeEditorProps {
    value: AdsrData;
    onChange: (newValue: AdsrData) => void;
    width?: number;
    height?: number;
    maxTime?: number; // Maximum time for the envelope's x-axis in seconds
}

// --- STYLES ---

const containerStyle: React.CSSProperties = {
    touchAction: 'none',
    WebkitUserSelect: 'none',
    userSelect: 'none',
    cursor: 'default',
    padding: '10px',
    background: '#252526',
    borderRadius: '8px',
};

const pointStyle: React.CSSProperties = {
    cursor: 'move',
    fill: '#3182CE',
    stroke: '#E2E8F0',
    strokeWidth: 2,
    transition: 'r 0.1s ease-in-out',
};

const lineStyle: React.CSSProperties = {
    fill: 'none',
    stroke: '#4A5568',
    strokeWidth: 2,
};

const fillStyle: React.CSSProperties = {
    fill: 'rgba(66, 153, 225, 0.3)',
};

const textLabelStyle: React.CSSProperties = {
    fill: '#A0AEC0',
    fontSize: '11px',
    textAnchor: 'middle',
    pointerEvents: 'none',
};

const readoutContainerStyle: React.CSSProperties = {
    display: 'flex',
    justifyContent: 'space-around',
    marginTop: '10px',
    fontFamily: 'monospace',
    fontSize: '12px',
    color: '#E0E0E0',
};

// --- MAIN COMPONENT ---

export const AdsrEnvelopeEditor: React.FC<AdsrEnvelopeEditorProps> = ({
    value,
    onChange,
    width = 300,
    height = 150,
    maxTime = 4.0, // Default max time of 4 seconds
}) => {
    const svgRef = useRef<SVGSVGElement>(null);
    const [draggedPoint, setDraggedPoint] = useState<string | null>(null);
    const valueRef = useRef(value);
    valueRef.current = value;

    const yPadding = 10;
    const visualHoldDuration = 0.1; // Sustain phase will be 10% of the graph width

    // --- Coordinate Scaling ---
    const scaleX = (time: number) => (time / maxTime) * width;
    const scaleY = (level: number) => (height - yPadding * 2) * (1 - level) + yPadding;
    const levelAtY = (posY: number) => 1 - ((posY - yPadding) / (height - yPadding * 2));
    const timeAtX = (posX: number) => (posX / width) * maxTime;

    const { attack, decay, sustain, release } = value;
    
    // Calculate positions based on A, D, R times and a fixed visual sustain period
    const sustainStartTime = attack + decay;
    const sustainEndTime = sustainStartTime + (maxTime * visualHoldDuration);
    const releaseEndTime = sustainEndTime + release;

    const points = {
        p1: { x: 0, y: height - yPadding },
        p2: { x: scaleX(attack), y: yPadding },
        p3: { x: scaleX(sustainStartTime), y: scaleY(sustain) },
        p4: { x: scaleX(sustainEndTime), y: scaleY(sustain) },
        p5: { x: scaleX(releaseEndTime), y: height - yPadding },
    };

    const pathData = `M ${points.p1.x},${points.p1.y} L ${points.p2.x},${points.p2.y} L ${points.p3.x},${points.p3.y} L ${points.p4.x},${points.p4.y} L ${points.p5.x},${points.p5.y}`;
    const fillPathData = `${pathData} L ${scaleX(maxTime)},${height} L 0,${height} Z`;

    const handleMouseDown = (e: React.MouseEvent, pointName: string) => {
        e.preventDefault();
        setDraggedPoint(pointName);
    };

    const handleMouseUp = useCallback(() => {
        setDraggedPoint(null);
    }, []);

    const handleMouseMove = useCallback((e: MouseEvent) => {
        if (!draggedPoint || !svgRef.current) return;
        e.preventDefault();

        const rect = svgRef.current.getBoundingClientRect();
        const x = Math.max(0, Math.min(width, e.clientX - rect.left));
        const y = Math.max(yPadding, Math.min(height - yPadding, e.clientY - rect.top));

        const newValues = { ...valueRef.current };

        switch (draggedPoint) {
            case 'attack': { // P2
                newValues.attack = Math.max(0.001, timeAtX(x));
                // Prevent attack from overlapping decay
                if (newValues.attack + newValues.decay > maxTime) {
                    newValues.decay = maxTime - newValues.attack;
                }
                break;
            }
            case 'decay': { // P3
                const decayEndTime = timeAtX(x);
                newValues.decay = Math.max(0.001, decayEndTime - newValues.attack);
                newValues.sustain = Math.max(0, Math.min(1, levelAtY(y)));
                break;
            }
            case 'release': { // P5
                const releaseStartTime = newValues.attack + newValues.decay + (maxTime * visualHoldDuration);
                newValues.release = Math.max(0.001, timeAtX(x) - releaseStartTime);
                break;
            }
        }
        onChange(newValues);
    }, [draggedPoint, width, height, onChange, maxTime]);

    useEffect(() => {
        if (draggedPoint) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [draggedPoint, handleMouseMove, handleMouseUp]);

    const renderControlPoint = (name: string, cx: number, cy: number) => (
        <circle
            cx={cx}
            cy={cy}
            r={draggedPoint === name ? 10 : 8}
            style={pointStyle}
            onMouseDown={(e) => handleMouseDown(e, name)}
        />
    );

    return (
        <div style={containerStyle}>
            <svg ref={svgRef} width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
                <path d={fillPathData} style={fillStyle} />
                <path d={pathData} style={lineStyle} />

                {renderControlPoint('attack', points.p2.x, points.p2.y)}
                {renderControlPoint('decay', points.p3.x, points.p3.y)}
                {/* The fourth point is now purely visual and not interactive */}
                <circle cx={points.p4.x} cy={points.p4.y} r="6" style={{...pointStyle, fill: '#4A5568', cursor: 'default'}} />
                {renderControlPoint('release', points.p5.x, points.p5.y)}

                <text x={points.p2.x} y={height - 5} style={textLabelStyle}>A</text>
                <text x={points.p3.x} y={height - 5} style={textLabelStyle}>D</text>
                <text x={points.p4.x} y={height - 5} style={textLabelStyle}>S</text>
                <text x={points.p5.x > 15 ? points.p5.x - 10 : 5} y={height - 5} style={textLabelStyle}>R</text>
            </svg>
            <div style={readoutContainerStyle}>
                <div>A: {attack.toFixed(2)}s</div>
                <div>D: {decay.toFixed(2)}s</div>
                <div>S: {sustain.toFixed(2)}</div>
                <div>R: {release.toFixed(2)}s</div>
            </div>
        </div>
    );
};


--- END FILE: components/controls/AdsrEnvelopeEditor.tsx ---

--- START FILE: components/controls/BpmSyncControl.tsx ---

import React from 'react';

// --- STYLES ---

const selectStyles: React.CSSProperties = {
    width: '100%',
    padding: '8px',
    boxSizing: 'border-box',
    borderRadius: '4px',
    border: '1px solid #555',
    background: '#333',
    color: '#E0E0E0',
    outline: 'none',
};

// --- PROPS INTERFACE ---

interface BpmSyncControlProps {
    value: string; // e.g., "1/4", "1/8t"
    onChange: (newDivision: string) => void;
}

// --- Note Divisions ---
// These are common musical subdivisions.
const noteDivisions = [
    "1/64t", "1/64", "1/32t", "1/32", "1/16t", "1/16", "1/8t", "1/8", 
    "1/4t", "1/4", "1/2t", "1/2", "1/1"
];


// --- MAIN COMPONENT ---

export const BpmSyncControl: React.FC<BpmSyncControlProps> = ({ value, onChange }) => {
    
    const handleSelectionChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        onChange(e.target.value);
    };

    return (
        <select
            style={selectStyles}
            value={value}
            onChange={handleSelectionChange}
        >
            {noteDivisions.map(division => (
                <option key={division} value={division}>
                    {division}
                </option>
            ))}
        </select>
    );
};

--- END FILE: components/controls/BpmSyncControl.tsx ---

--- START FILE: components/controls/CustomSlider.tsx ---

import React, { useState, useEffect, useCallback } from 'react';

// --- STYLES ---

const containerStyles: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    width: '100%',
};

const sliderStyles: React.CSSProperties = {
    flexGrow: 1,
    marginRight: '10px',
    accentColor: '#3182CE',
};

const numberInputStyles: React.CSSProperties = {
    width: '70px',
    padding: '8px',
    boxSizing: 'border-box',
    borderRadius: '4px',
    border: '1px solid #555',
    background: '#333',
    color: '#E0E0E0',
    outline: 'none',
    textAlign: 'right',
};

// --- PROPS INTERFACE ---

interface CustomSliderProps {
    min: number;
    max: number;
    value: number;
    onChange: (newValue: number) => void;
    scale?: 'log' | 'linear';
    step?: number;
    defaultValue?: number;
    onReset?: () => void;
    exponent?: number;
    className?: string; // Allow className to be passed
}

// --- HELPER FUNCTIONS for scaling ---

const toLogValue = (position: number, min: number, max: number) => {
    const minLog = Math.log(min);
    const maxLog = Math.log(max);
    const scale = (maxLog - minLog) / 100;
    return Math.exp(minLog + scale * position);
};

const fromLogValue = (value: number, min: number, max: number) => {
    if (value <= 0) return 0; // Avoid log(0)
    const minLog = Math.log(min);
    const maxLog = Math.log(max);
    const scale = (maxLog - minLog) / 100;
    return (Math.log(value) - minLog) / scale;
};

// --- MAIN COMPONENT ---

export const CustomSlider: React.FC<CustomSliderProps> = ({
    min,
    max,
    value,
    onChange,
    scale = 'linear',
    step = 0.01,
    defaultValue = 0,
    onReset = () => {},
}) => {
    // Internal state for immediate UI feedback
    const [localValue, setLocalValue] = useState(value);
    // Separate state for the text input to allow temporary invalid strings
    const [textValue, setTextValue] = useState(value.toString());

    // Sync local state if the incoming prop changes
    useEffect(() => {
        setLocalValue(value);
        setTextValue(value.toString());
    }, [value]);

    const getSliderPosition = useCallback(() => {
        if (scale === 'log') return fromLogValue(localValue, min, max);
        return ((localValue - min) / (max - min)) * 100;
    }, [localValue, min, max, scale]);

    const handleSliderChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const newPosition = parseFloat(e.target.value);
        let newValue: number;
        if (scale === 'log') {
            newValue = toLogValue(newPosition, min, max);
        } else {
            newValue = min + (max - min) * (newPosition / 100);
        }
        // Clamp and format the value to avoid floating point inaccuracies
        const clampedValue = Math.max(min, Math.min(max, newValue));
        const finalValue = parseFloat(clampedValue.toPrecision(5));
        
        setLocalValue(finalValue);
        setTextValue(finalValue.toString());
        onChange(finalValue);
    };
    
    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setTextValue(e.target.value);
    };

    const handleInputBlur = () => {
        let parsed = parseFloat(textValue);
        if (textValue.toLowerCase().includes('k')) {
            parsed = parseFloat(textValue.replace(/k/i, '')) * 1000;
        }

        if (isNaN(parsed)) {
            setLocalValue(defaultValue);
            setTextValue(defaultValue.toString());
            onChange(defaultValue);
        } else {
            const clampedValue = Math.max(min, Math.min(max, parsed));
            setLocalValue(clampedValue);
            setTextValue(clampedValue.toString());
            onChange(clampedValue);
        }
    };

    const handleInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
        if (e.key === 'Enter') {
            handleInputBlur();
            (e.target as HTMLInputElement).blur();
        }
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const smallStep = step * (e.shiftKey ? 0.1 : 1);
            const direction = e.key === 'ArrowUp' ? 1 : -1;
            const newValue = Math.max(min, Math.min(max, localValue + smallStep * direction));
            const finalValue = parseFloat(newValue.toPrecision(5));

            setLocalValue(finalValue);
            setTextValue(finalValue.toString());
            onChange(finalValue);
        }
    };

    const handleDoubleClick = (e: React.MouseEvent) => {
        if (e.ctrlKey || e.metaKey) {
            setLocalValue(defaultValue);
            setTextValue(defaultValue.toString());
            onReset();
        }
    };

    return (
        <div style={containerStyles} onDoubleClick={handleDoubleClick} title="Ctrl/Cmd + Double Click to Reset">
            <input
                type="range"
                min="0"
                max="100"
                value={getSliderPosition()}
                onChange={handleSliderChange}
                style={sliderStyles}
                step="0.1" // Finer control on the range input itself
            />
            <input
                type="text"
                value={textValue}
                onChange={handleInputChange}
                onBlur={handleInputBlur}
                onKeyDown={handleInputKeyDown}
                style={numberInputStyles}
            />
        </div>
    );
};



--- END FILE: components/controls/CustomSlider.tsx ---

--- START FILE: components/controls/XYPad.tsx ---

import React, { useState, useRef, useCallback, useEffect } from 'react';

// --- PROPS INTERFACE ---

interface XYPadProps {
    xValue: number;
    yValue: number;
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
    onChange: (values: { x: number; y: number }) => void;
    xScale?: 'log' | 'linear';
    yScale?: 'log' | 'linear';
    width?: number;
    height?: number;
}

// --- STYLES ---

const padStyle: React.CSSProperties = {
    width: '100%',
    height: '200px',
    background: '#252526',
    border: '1px solid #4A5568',
    borderRadius: '8px',
    position: 'relative',
    cursor: 'crosshair',
    touchAction: 'none',
    WebkitUserSelect: 'none',
    userSelect: 'none',
};

const handleStyle: React.CSSProperties = {
    position: 'absolute',
    width: '20px',
    height: '20px',
    background: '#3182CE',
    border: '2px solid #E0E0E0',
    borderRadius: '50%',
    transform: 'translate(-50%, -50%)',
    pointerEvents: 'none', // Prevent handle from capturing mouse events
};

const gridLineStyle: React.CSSProperties = {
    stroke: '#4A5568',
    strokeWidth: 0.5,
};

// --- HELPER FUNCTIONS ---
const toLogValue = (position: number, min: number, max: number) => {
    const minLog = Math.log(min);
    const maxLog = Math.log(max);
    const scale = maxLog - minLog;
    return Math.exp(minLog + scale * position);
};

const fromLogValue = (value: number, min: number, max: number) => {
    if (value <= 0) return 0;
    const minLog = Math.log(min);
    const maxLog = Math.log(max);
    const scale = maxLog - minLog;
    if (scale === 0) return 0;
    return (Math.log(value) - minLog) / scale;
};


// --- MAIN COMPONENT ---

export const XYPad: React.FC<XYPadProps> = ({
    xValue,
    yValue,
    minX,
    maxX,
    minY,
    maxY,
    onChange,
    xScale = 'linear',
    yScale = 'linear',
    width = 250,
    height = 200,
}) => {
    const padRef = useRef<HTMLDivElement>(null);
    const [isDragging, setIsDragging] = useState(false);
    const [localPosition, setLocalPosition] = useState({ x: xValue, y: yValue });

    useEffect(() => {
        setLocalPosition({ x: xValue, y: yValue });
    }, [xValue, yValue]);

    const getPositionFromValue = (valX: number, valY: number) => {
        const xPos = xScale === 'log' 
            ? fromLogValue(valX, minX, maxX)
            : (valX - minX) / (maxX - minX);

        const yPos = yScale === 'log'
            ? fromLogValue(valY, minY, maxY)
            : (valY - minY) / (maxY - minY);

        return {
            x: xPos * width,
            y: (1 - yPos) * height,
        };
    };

    const handleInteraction = useCallback((clientX: number, clientY: number) => {
        if (!padRef.current) return;

        const rect = padRef.current.getBoundingClientRect();
        let x = (clientX - rect.left) / width;
        let y = 1 - ((clientY - rect.top) / height);
        
        x = Math.max(0, Math.min(1, x));
        y = Math.max(0, Math.min(1, y));

        const newXValue = xScale === 'log' ? toLogValue(x, minX, maxX) : minX + x * (maxX - minX);
        const newYValue = yScale === 'log' ? toLogValue(y, minY, maxY) : minY + y * (maxY - minY);

        setLocalPosition({ x: newXValue, y: newYValue });

    }, [width, height, minX, maxX, minY, maxY, xScale, yScale]);

    const handleMouseDown = (e: React.MouseEvent) => {
        setIsDragging(true);
        handleInteraction(e.clientX, e.clientY);
    };

    const handleMouseUp = useCallback(() => {
        if (isDragging) {
            onChange(localPosition);
            setIsDragging(false);
        }
    }, [isDragging, localPosition, onChange]);

    const handleMouseMove = useCallback((e: MouseEvent) => {
        if (isDragging) {
            handleInteraction(e.clientX, e.clientY);
        }
    }, [isDragging, handleInteraction]);

    useEffect(() => {
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [handleMouseMove, handleMouseUp]);

    const pos = getPositionFromValue(localPosition.x, localPosition.y);

    return (
        <div
            ref={padRef}
            style={{...padStyle, width: `${width}px`, height: `${height}px`}}
            onMouseDown={handleMouseDown}
        >
            <svg width="100%" height="100%" style={{ position: 'absolute' }}>
                <line x1={width/2} y1="0" x2={width/2} y2={height} style={gridLineStyle} />
                <line x1="0" y1={height/2} x2={width} y2={height/2} style={gridLineStyle} />
            </svg>
            <div style={{ ...handleStyle, left: `${pos.x}px`, top: `${pos.y}px` }} />
        </div>
    );
};


--- END FILE: components/controls/XYPad.tsx ---

--- START FILE: hooks/nodeEditor/instrument.ts ---

// skald-ui/src/hooks/nodeEditor/instrument.ts
import { Node } from 'reactflow';
import { Voice } from './voice';

export class Instrument {
    public input: GainNode; // Main input for the instrument (not used yet)
    public output: GainNode; // Main output for the instrument
    private context: AudioContext;
    private voices: Voice[] = [];
    private nextVoiceIndex = 0;
    private nodeData: any;

    constructor(context: AudioContext, node: Node) {
        this.context = context;
        this.input = context.createGain();
        this.output = context.createGain();
        this.nodeData = node.data;

        const voiceCount = this.nodeData.voiceCount || 8;
        const subgraph = {
            nodes: this.nodeData.subgraph.nodes,
            edges: this.nodeData.subgraph.connections.map((c: any) => ({
                id: `e${c.from_node}-${c.to_node}`,
                source: c.from_node.toString(),
                target: c.to_node.toString(),
                sourceHandle: c.from_port,
                targetHandle: c.to_port,
            }))
        };

        for (let i = 0; i < voiceCount; i++) {
            const voice = new Voice(context, subgraph);
            voice.connect(this.output);
            this.voices.push(voice);
        }
    }

    // Simple trigger for testing. Will trigger the next available voice.
    public trigger() {
        const voice = this.voices[this.nextVoiceIndex];
        if (voice) {
            voice.trigger(this.context.currentTime);
        }
        this.nextVoiceIndex = (this.nextVoiceIndex + 1) % this.voices.length;
    }

    public connect(destination: AudioNode | AudioParam) {
        this.output.connect(destination);
    }

    public disconnect() {
        this.output.disconnect();
        this.voices.forEach(v => v.disconnect());
    }

    public updateNodeData(data: any) {
         Object.keys(data).forEach(key => {
            const value = data[key];
            // Check if this is a parameter for a sub-node
            if(typeof value === 'object' && value.subNodeId) {
                this.voices.forEach(voice => {
                    voice.updateNodeData(value.subNodeId, value.data);
                });
            }
        });
    }
}

--- END FILE: hooks/nodeEditor/instrument.ts ---

--- START FILE: hooks/nodeEditor/useAudioEngine.ts ---

import { useState, useRef, useCallback, useEffect } from 'react';
import { Node, Edge, Connection } from 'reactflow';
import useDeepCompareEffect from 'use-deep-compare-effect';

// =================================================================================
// SECTION A: FORWARD-DECLARED TYPES & AUDIO WORKLETS
// =================================================================================

type AdsrDataMap = Map<string, { gainNode: GainNode; data: any }>;

// These string definitions remain unchanged.
const sampleHoldProcessorString = `
class SampleHoldProcessor extends AudioWorkletProcessor {
  static get parameterDescriptors() {
    return [{ name: 'rate', defaultValue: 10.0, minValue: 0 }];
  }
  constructor() {
    super();
    this.updateInterval = 1 / 10.0 * sampleRate;
    this.value = Math.random() * 2 - 1;
    this.counter = 0;
  }
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    const rate = parameters.rate[0];
    this.updateInterval = 1 / rate * sampleRate;
    for (let channel = 0; channel < output.length; ++channel) {
      const outputChannel = output[channel];
      for (let i = 0; i < outputChannel.length; ++i) {
        if (this.counter >= this.updateInterval) {
            this.value = Math.random() * 2 - 1;
            this.counter = 0;
        }
        outputChannel[i] = this.value;
        this.counter++;
      }
    }
    return true;
  }
}
registerProcessor('sample-hold-processor', SampleHoldProcessor);
`;

const wavetableProcessorString = `
class WavetableProcessor extends AudioWorkletProcessor {
    static get parameterDescriptors() {
        return [
            { name: 'frequency', defaultValue: 440, minValue: 20, maxValue: 20000 },
            { name: 'position', defaultValue: 0, minValue: 0, maxValue: 3 },
        ];
    }
    constructor(options) {
        super(options);
        this.phase = 0;
        this.tables = this.createTables();
    }
    createTables() {
        const size = 2048;
        const sine = new Float32Array(size);
        const triangle = new Float32Array(size);
        const sawtooth = new Float32Array(size);
        const square = new Float32Array(size);
        for (let i = 0; i < size; i++) {
            const angle = (i / size) * 2 * Math.PI;
            sine[i] = Math.sin(angle);
            triangle[i] = (Math.abs((i / size) * 4 - 2) - 1);
            sawtooth[i] = (i / size) * 2 - 1;
            square[i] = (i < size / 2) ? 1 : -1;
        }
        return [sine, triangle, sawtooth, square];
    }
    process(inputs, outputs, parameters) {
        const output = outputs[0];
        const frequency = parameters.frequency;
        const position = parameters.position;
        for (let channel = 0; channel < output.length; ++channel) {
            const outputChannel = output[channel];
            for (let i = 0; i < outputChannel.length; ++i) {
                const freq = frequency.length > 1 ? frequency[i] : frequency[0];
                const pos = position.length > 1 ? position[i] : position[0];
                const tableIndex = Math.floor(pos);
                const nextTableIndex = (tableIndex + 1) % this.tables.length;
                const tableFraction = pos - tableIndex;
                const table1 = this.tables[tableIndex];
                const table2 = this.tables[nextTableIndex];
                const readIndex = (this.phase * table1.length);
                const readIndexInt = Math.floor(readIndex);
                const readIndexFrac = readIndex - readIndexInt;
                const v1_1 = table1[readIndexInt % table1.length];
                const v1_2 = table1[(readIndexInt + 1) % table1.length];
                const sample1 = v1_1 + (v1_2 - v1_1) * readIndexFrac;
                const v2_1 = table2[readIndexInt % table2.length];
                const v2_2 = table2[(readIndexInt + 1) % table2.length];
                const sample2 = v2_1 + (v2_2 - v2_1) * readIndexFrac;
                outputChannel[i] = sample1 + (sample2 - sample1) * tableFraction;
                this.phase += freq / sampleRate;
                if (this.phase > 1) this.phase -= 1;
            }
        }
        return true;
    }
}
registerProcessor('wavetable-processor', WavetableProcessor);
`;

// =================================================================================
// SECTION B: HELPER FUNCTIONS
// =================================================================================

const connectNodes = (sourceNode: AudioNode, targetNode: any, edge: Edge | Connection) => {
    try {
        if (targetNode instanceof AudioWorkletNode && edge.targetHandle?.startsWith('input_')) {
            const paramName = edge.targetHandle.substring(6);
            const param = targetNode.parameters.get(paramName);
            if (param) sourceNode.connect(param);
        } else if (targetNode[edge.targetHandle as keyof AudioNode] instanceof AudioParam) {
            sourceNode.connect(targetNode[edge.targetHandle as keyof AudioNode]);
        } else {
            sourceNode.connect(targetNode);
        }
    } catch (e) {
        console.error(`Failed to connect ${edge.source} to ${edge.target}`, e);
    }
};

const disconnectNodes = (sourceNode: AudioNode, targetNode: any, edge: Edge | Connection) => {
    try {
        if (targetNode instanceof AudioWorkletNode && edge.targetHandle?.startsWith('input_')) {
            const paramName = edge.targetHandle.substring(6);
            const param = targetNode.parameters.get(paramName);
            if (param) sourceNode.disconnect(param);
        } else if (targetNode[edge.targetHandle as keyof AudioNode] instanceof AudioParam) {
            sourceNode.disconnect(targetNode[edge.targetHandle as keyof AudioNode]);
        } else {
            sourceNode.disconnect(targetNode);
        }
    } catch (e) {
        // Errors are expected here if a node was deleted, so we can ignore them.
    }
};

const createAudioNode = (context: AudioContext, node: Node, adsrDataMap: AdsrDataMap): AudioNode | null => {
    let audioNode: AudioNode | null = null;
    switch (node.type) {
        case 'adsr': {
            const gainNode = context.createGain();
            gainNode.gain.setValueAtTime(0, context.currentTime);
            adsrDataMap.set(node.id, { gainNode, data: node.data });
            audioNode = gainNode;
            break;
        }
        case 'oscillator': {
            const osc = context.createOscillator();
            osc.type = (node.data.waveform || 'sawtooth').toLowerCase() as OscillatorType;
            osc.frequency.setValueAtTime(node.data.frequency || 440, context.currentTime);
            osc.start();
            audioNode = osc;
            break;
        }
        case 'noise': {
            const buffer = context.createBuffer(1, context.sampleRate * 2, context.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) { data[i] = Math.random() * 2 - 1; }
            const noiseSource = context.createBufferSource();
            noiseSource.buffer = buffer;
            noiseSource.loop = true;
            noiseSource.start();
            audioNode = noiseSource;
            break;
        }
        case 'wavetable': {
            const wtNode = new AudioWorkletNode(context, 'wavetable-processor');
            wtNode.parameters.get('frequency')?.setValueAtTime(node.data.frequency || 440, context.currentTime);
            wtNode.parameters.get('position')?.setValueAtTime(node.data.position || 0, context.currentTime);
            audioNode = wtNode;
            break;
        }
        case 'filter': {
            const filter = context.createBiquadFilter();
            filter.type = (node.data.type || 'lowpass').toLowerCase() as BiquadFilterType;
            filter.frequency.setValueAtTime(node.data.cutoff || 800, context.currentTime);
            filter.Q.setValueAtTime(node.data.resonance || 1.0, context.currentTime);
            audioNode = filter;
            break;
        }
        case 'lfo': {
            const lfo = context.createOscillator();
            lfo.type = (node.data.waveform || 'sine').toLowerCase() as OscillatorType;
            lfo.frequency.setValueAtTime(node.data.frequency || 5.0, context.currentTime);
            lfo.start();
            const lfoGain = context.createGain();
            lfoGain.gain.setValueAtTime(node.data.amplitude || 1.0, context.currentTime);
            lfo.connect(lfoGain);
            audioNode = lfoGain;
            break;
        }
        case 'output': {
            const outputGain = context.createGain();
            outputGain.connect(context.destination);
            audioNode = outputGain;
            break;
        }
        case 'InstrumentInput': {
             const inputGain = context.createGain();
             audioNode = inputGain;
             break;
        }
         case 'InstrumentOutput': {
             const outputGain = context.createGain();
             audioNode = outputGain;
             break;
        }
        default:
            audioNode = context.createGain();
            break;
    }
    return audioNode;
}

// =================================================================================
// SECTION C: COMPOSITE NODE CLASSES (INSTRUMENT & VOICE)
// =================================================================================

class Voice {
    private audioContext: AudioContext;
    private internalNodes: Map<string, AudioNode> = new Map();
    private adsrData: AdsrDataMap = new Map();
    public output: GainNode;
    private subgraph: { nodes: Node[]; connections: Edge[] };
    public input: GainNode;

    constructor(context: AudioContext, subgraph: { nodes: Node[]; connections: Edge[] }) {
        this.audioContext = context;
        this.subgraph = subgraph;
        this.input = context.createGain();
        this.output = context.createGain();
        this.buildSubgraph();
    }

    private buildSubgraph() {
        // Create all internal audio nodes
        this.subgraph.nodes.forEach(node => {
            const audioNode = createAudioNode(this.audioContext, node, this.adsrData);
            if (audioNode) {
                this.internalNodes.set(node.id, audioNode);
            }
        });

        // Connect the internal nodes
        this.subgraph.connections.forEach(edge => {
            const sourceNode = this.internalNodes.get(edge.source);
            const targetNode = this.internalNodes.get(edge.target);
            if (sourceNode && targetNode) {
                connectNodes(sourceNode, targetNode, edge);
            }
        });

        // Connect the special 'InstrumentInput' to the voice's main input
        this.subgraph.nodes.filter(n => n.type === 'InstrumentInput').forEach(inputNode => {
            const internalInNode = this.internalNodes.get(inputNode.id);
            if (internalInNode) {
                this.input.connect(internalInNode);
            }
        });

        // Connect the final output of the subgraph to the voice's main output
        this.subgraph.nodes.filter(n => n.type === 'InstrumentOutput').forEach(outputNode => {
             const internalOutNode = this.internalNodes.get(outputNode.id);
             if (internalOutNode) {
                 internalOutNode.connect(this.output);
             }
        });
    }

    public trigger(startTime: number) {
        this.adsrData.forEach(({ gainNode, data }) => {
            const { attack = 0.01, decay = 0.1, sustain = 0.8 } = data;
            gainNode.gain.cancelScheduledValues(startTime);
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(1, startTime + attack);
            gainNode.gain.linearRampToValueAtTime(sustain, startTime + attack + decay);
        });
    }

    public release(startTime: number) {
        this.adsrData.forEach(({ gainNode, data }) => {
            const { release = 0.5 } = data;
            const currentGain = gainNode.gain.value;
            gainNode.gain.cancelScheduledValues(startTime);
            gainNode.gain.setValueAtTime(currentGain, startTime);
            gainNode.gain.linearRampToValueAtTime(0, startTime + release);
        });
    }
    
    public connect(destination: AudioNode | AudioParam) {
        this.output.connect(destination);
    }
    
    public disconnect() {
        this.output.disconnect();
        this.internalNodes.forEach(node => node.disconnect());
    }

    public updateNodeData(nodeId: string, data: any) {
        const nodeToUpdate = this.internalNodes.get(nodeId);
        const nodeDef = this.subgraph.nodes.find(n => n.id === nodeId);
        if (!nodeToUpdate || !nodeDef) return;

        const now = this.audioContext.currentTime;
        const rampTime = 0.02;

        if (nodeToUpdate instanceof OscillatorNode) {
            if (data.frequency !== undefined) nodeToUpdate.frequency.setTargetAtTime(data.frequency, now, rampTime);
        } else if (nodeToUpdate instanceof BiquadFilterNode) {
            if (data.cutoff !== undefined) nodeToUpdate.frequency.setTargetAtTime(data.cutoff, now, rampTime);
            if (data.resonance !== undefined) nodeToUpdate.Q.setTargetAtTime(data.resonance, now, rampTime);
        } else if (nodeToUpdate instanceof GainNode && (nodeDef.type === 'adsr' || nodeDef.type === 'lfo')) {
             if (data.amplitude !== undefined) nodeToUpdate.gain.setTargetAtTime(data.amplitude, now, rampTime);
             const adsr = this.adsrData.get(nodeId);
             if (adsr) adsr.data = { ...adsr.data, ...data };
        } else if (nodeToUpdate instanceof AudioWorkletNode) {
            if (nodeDef.type === 'wavetable') {
                 if(data.frequency !== undefined) nodeToUpdate.parameters.get('frequency')?.setTargetAtTime(data.frequency, now, rampTime);
                 if(data.position !== undefined) nodeToUpdate.parameters.get('position')?.setTargetAtTime(data.position, now, rampTime);
            }
        }
    }
}

class Instrument {
    public input: GainNode;
    public output: GainNode;
    private context: AudioContext;
    private voices: Voice[] = [];
    private nextVoiceIndex = 0;

    constructor(context: AudioContext, node: Node) {
        this.context = context;
        this.input = context.createGain();
        this.output = context.createGain();

        const { voiceCount = 8, subgraph } = node.data;
        if (!subgraph || !subgraph.nodes || !subgraph.connections) {
            console.error("Instrument node is missing a valid subgraph.", node);
            return;
        }

        const reactFlowEdges: Edge[] = subgraph.connections.map((c: any) => ({
            id: `e${c.from_node}-${c.to_node}`,
            source: String(c.from_node),
            target: String(c.to_node),
            sourceHandle: c.from_port,
            targetHandle: c.to_port,
        }));
        const fullSubgraph = { nodes: subgraph.nodes, connections: reactFlowEdges };

        for (let i = 0; i < voiceCount; i++) {
            const voice = new Voice(context, fullSubgraph);
            this.input.connect(voice.input); // Connect master input to each voice
            voice.connect(this.output);
            this.voices.push(voice);
        }
    }
    
    public trigger() {
        const voice = this.voices[this.nextVoiceIndex];
        if (voice) {
            voice.trigger(this.context.currentTime);
        }
        this.nextVoiceIndex = (this.nextVoiceIndex + 1) % this.voices.length;
    }

    public connect(destination: AudioNode | AudioParam, outputIndex?: number, inputIndex?: number) {
        this.output.connect(destination, outputIndex, inputIndex);
    }
    
    public disconnect() {
        this.output.disconnect();
        this.voices.forEach(v => v.disconnect());
    }

    public updateNodeData(data: any) {
        this.voices.forEach(voice => {
            if(data.subgraph && data.subgraph.nodes) {
                data.subgraph.nodes.forEach((subNode: Node) => {
                    voice.updateNodeData(subNode.id, subNode.data);
                });
            }
        });
    }
}


// =================================================================================
// SECTION D: MAIN AUDIO ENGINE HOOK
// =================================================================================

export const useAudioEngine = (nodes: Node[], edges: Edge[], isLooping: boolean, bpm: number) => {
    const [isPlaying, setIsPlaying] = useState(false);
    const audioContext = useRef<AudioContext | null>(null);
    const audioNodes = useRef<Map<string, AudioNode | Instrument>>(new Map());
    const adsrNodes = useRef<AdsrDataMap>(new Map());
    const loopIntervalId = useRef<NodeJS.Timeout | null>(null);
    const prevGraphState = useRef<{ nodes: Node[], edges: Edge[] }>({ nodes: [], edges: [] });

    const triggerAdsr = (gainNode: GainNode, data: any, startTime: number) => {
        const { attack = 0.1, decay = 0.2, sustain = 0.5 } = data;
        gainNode.gain.cancelScheduledValues(startTime);
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(1, startTime + attack);
        gainNode.gain.linearRampToValueAtTime(sustain, startTime + attack + decay);
    };
    
    const startSequencer = useCallback(() => {
        if (loopIntervalId.current) clearInterval(loopIntervalId.current);
        const loopDuration = (60 / bpm) * 4 * 1000; // 4 beats

        const tick = () => {
            if (!audioContext.current) return;
            const now = audioContext.current.currentTime;
            
            // Trigger global (non-instrument) ADSRs
            adsrNodes.current.forEach(({ gainNode, data }) => {
                triggerAdsr(gainNode, data, now);
            });

            // Trigger all instruments
            audioNodes.current.forEach(node => {
                if (node instanceof Instrument) {
                    node.trigger();
                }
            });
        };
        
        tick(); // Trigger immediately
        loopIntervalId.current = setInterval(tick, loopDuration);
    }, [bpm]);

    const stopSequencer = () => {
        if (loopIntervalId.current) {
            clearInterval(loopIntervalId.current);
            loopIntervalId.current = null;
        }
    };

    const handlePlay = useCallback(async () => {
        if (isPlaying) return;
        const context = new AudioContext();
        audioContext.current = context;
        try {
            const sampleHoldBlob = new Blob([sampleHoldProcessorString], { type: 'application/javascript' });
            const wavetableBlob = new Blob([wavetableProcessorString], { type: 'application/javascript' });
            await Promise.all([
                context.audioWorklet.addModule(URL.createObjectURL(sampleHoldBlob)),
                context.audioWorklet.addModule(URL.createObjectURL(wavetableBlob))
            ]);
            setIsPlaying(true);
        } catch (e) {
            console.error('Error loading AudioWorklet:', e);
            audioContext.current = null;
        }
    }, [isPlaying]);

    const handleStop = useCallback(() => {
        stopSequencer();
        if (!isPlaying || !audioContext.current) return;
        audioContext.current.close().then(() => {
            setIsPlaying(false);
            audioContext.current = null;
            audioNodes.current.clear();
            adsrNodes.current.clear();
            prevGraphState.current = { nodes: [], edges: [] };
        });
    }, [isPlaying]);

    useDeepCompareEffect(() => {
        if (!isPlaying || !audioContext.current) return;
        
        const { nodes: prevNodes, edges: prevEdges } = prevGraphState.current;
        const context = audioContext.current;

        const prevNodeIds = new Set(prevNodes.map(n => n.id));
        const currentNodeIds = new Set(nodes.map(n => n.id));

        prevNodes.forEach(node => {
            if (!currentNodeIds.has(node.id)) {
                const audioNode = audioNodes.current.get(node.id);
                if (audioNode) {
                    audioNode.disconnect();
                    audioNodes.current.delete(node.id);
                    if (node.type === 'adsr') adsrNodes.current.delete(node.id);
                }
            }
        });

        nodes.forEach(node => {
            const liveNode = audioNodes.current.get(node.id);
            if (!liveNode) {
                let newAudioNode: AudioNode | Instrument | null = null;
                if (node.type === 'instrument') {
                    newAudioNode = new Instrument(context, node);
                } else {
                    newAudioNode = createAudioNode(context, node, adsrNodes.current);
                }
                if (newAudioNode) audioNodes.current.set(node.id, newAudioNode);
            } else {
                const now = context.currentTime;
                const rampTime = 0.02;

                if (liveNode instanceof Instrument) {
                    liveNode.updateNodeData(node.data);
                } else if (liveNode instanceof OscillatorNode) {
                    liveNode.frequency.setTargetAtTime(node.data.frequency, now, rampTime);
                } else if (liveNode instanceof BiquadFilterNode) {
                    liveNode.frequency.setTargetAtTime(node.data.cutoff, now, rampTime);
                    liveNode.Q.setTargetAtTime(node.data.resonance, now, rampTime);
                } else if (liveNode instanceof GainNode && (node.type === 'adsr' || node.type === 'lfo')) {
                    if (node.data.amplitude !== undefined) liveNode.gain.setTargetAtTime(node.data.amplitude, now, rampTime);
                    const adsr = adsrNodes.current.get(node.id);
                    if (adsr) adsr.data = node.data;
                } else if (liveNode instanceof AudioWorkletNode) {
                    if (node.type === 'wavetable') {
                        liveNode.parameters.get('frequency')?.setTargetAtTime(node.data.frequency, now, rampTime);
                        liveNode.parameters.get('position')?.setTargetAtTime(node.data.position, now, rampTime);
                    }
                }
            }
        });

        const prevEdgeIds = new Set(prevEdges.map(e => e.id));
        const currentEdgeIds = new Set(edges.map(e => e.id));

        prevEdges.forEach(edge => {
            if (!currentEdgeIds.has(edge.id)) {
                const source = audioNodes.current.get(edge.source);
                const target = audioNodes.current.get(edge.target);
                if (source && target) {
                    const sourceNode = source instanceof Instrument ? source.output : source;
                    const targetNode = target instanceof Instrument ? target.input : target;
                    disconnectNodes(sourceNode, targetNode, edge);
                }
            }
        });

        edges.forEach(edge => {
            if (!prevEdgeIds.has(edge.id)) {
                const source = audioNodes.current.get(edge.source);
                const target = audioNodes.current.get(edge.target);
                if (source && target) {
                    const sourceNode = source instanceof Instrument ? source.output : source;
                    const targetNode = target instanceof Instrument ? target.input : target;
                    connectNodes(sourceNode, targetNode, edge);
                }
            }
        });

        prevGraphState.current = { nodes, edges };

    }, [nodes, edges, isPlaying]);

    useEffect(() => {
        if (isPlaying && isLooping) {
            startSequencer();
        } else {
            stopSequencer();
        }
        return stopSequencer;
    }, [isPlaying, isLooping, bpm, startSequencer]);

    useEffect(() => {
        return () => { if (audioContext.current) handleStop(); };
    }, [handleStop]);

    return { isPlaying, handlePlay, handleStop };
};

--- END FILE: hooks/nodeEditor/useAudioEngine.ts ---

--- START FILE: hooks/nodeEditor/useFileIO.ts ---

/*
================================================================================
| FILE: skald-ui/src/hooks/nodeEditor/useFileIO.ts                             |
|                                                                              |
| This hook handles all file input/output operations, like saving and loading  |
| the graph to and from the filesystem via the Electron main process.          |
================================================================================
*/
import { useCallback } from 'react';
import { Node, Edge, ReactFlowInstance } from 'reactflow';

export const useFileIO = (
    reactFlowInstance: ReactFlowInstance | null,
    setNodes: (nodes: Node[]) => void,
    setEdges: (edges: Edge[]) => void,
    setHistory: (history: any[]) => void,
    setFuture: (future: any[]) => void
) => {
    const handleSave = useCallback(() => {
        if (reactFlowInstance) {
            const flow = reactFlowInstance.toObject();
            const graphJson = JSON.stringify(flow, null, 2);
            window.electron.saveGraph(graphJson);
        }
    }, [reactFlowInstance]);

    const handleLoad = useCallback(async () => {
        const graphJson = await window.electron.loadGraph();
        if (graphJson) {
            const flow = JSON.parse(graphJson);
            if (flow) {
                const loadedNodes = flow.nodes || [];
                setNodes(loadedNodes);
                setEdges(flow.edges || []);
                const maxId = Math.max(0, ...loadedNodes.map((n: Node) => parseInt(n.id, 10) || 0));
                // This is a global, so we just set it. A bit of a code smell but it's how the original worked.
                // In a larger refactor, this `id` logic would live inside the useGraphState hook.
                // For now, we'll keep it as is to maintain functionality.
                // id = maxId; 
                setHistory([]);
                setFuture([]);
            }
        }
    }, [setNodes, setEdges, setHistory, setFuture]);

    return { handleSave, handleLoad };
};


--- END FILE: hooks/nodeEditor/useFileIO.ts ---

--- START FILE: hooks/nodeEditor/useGraphState.ts ---

/*
================================================================================
| FILE: skald-ui/src/hooks/nodeEditor/useGraphState.ts                         |
|                                                                              |
| This hook encapsulates all state and logic related to managing the           |
| React Flow graph itself, including nodes, edges, undo/redo, and grouping.    |
================================================================================
*/
import { useState, useCallback, useRef, useEffect } from 'react';
import {
    Node,
    Edge,
    OnNodesChange,
    OnEdgesChange,
    OnConnect,
    NodeChange,
    EdgeChange,
    addEdge,
    applyNodeChanges,
    applyEdgeChanges,
    useReactFlow,
    OnSelectionChangeParams,
} from 'reactflow';

const initialNodes: Node[] = [];
const initialEdges: Edge[] = [];

let id = 0;
const getId = () => ++id;

type HistoryState = { nodes: Node[]; edges: Edge[] };

export const useGraphState = () => {
    const { screenToFlowPosition } = useReactFlow();
    const [nodes, setNodes] = useState<Node[]>(initialNodes);
    const [edges, setEdges] = useState<Edge[]>(initialEdges);
    const [selectedNode, setSelectedNode] = useState<Node | null>(null);
    const [selectedNodesForGrouping, setSelectedNodesForGrouping] = useState<Node[]>([]);
    
    const [history, setHistory] = useState<HistoryState[]>([]);
    const [future, setFuture] = useState<HistoryState[]>([]);
    const isRestoring = useRef(false);

    const [isNamePromptVisible, setIsNamePromptVisible] = useState(false);

    useEffect(() => {
        if (selectedNode) {
            const updatedSelectedNode = nodes.find(node => node.id === selectedNode.id);
            if (updatedSelectedNode) {
                setSelectedNode(updatedSelectedNode);
            }
        }
    }, [nodes, selectedNode?.id]);

    const saveStateForUndo = useCallback(() => {
        if (isRestoring.current) return;
        setHistory(prev => [...prev, { nodes, edges }]);
        setFuture([]);
    }, [nodes, edges]);

    const onNodesChange: OnNodesChange = useCallback((changes: NodeChange[]) => {
        const isUndoable = changes.some(c => c.type === 'add' || c.type === 'remove' || (c.type === 'position' && !c.dragging));
        if (isUndoable) saveStateForUndo();
        setNodes(nds => applyNodeChanges(changes, nds));
    }, [saveStateForUndo]);

    const onEdgesChange: OnEdgesChange = useCallback((changes: EdgeChange[]) => {
        const isUndoable = changes.some(c => c.type === 'add' || c.type === 'remove');
        if (isUndoable) saveStateForUndo();
        setEdges(eds => applyEdgeChanges(changes, eds));
    }, [saveStateForUndo]);

    const onConnect: OnConnect = useCallback((connection) => {
        saveStateForUndo();
        const edge = { ...connection, id: `e${connection.source}-${connection.target}`, sourceHandle: connection.sourceHandle, targetHandle: connection.targetHandle };
        setEdges(eds => addEdge(edge, eds));
    }, [saveStateForUndo]);

    const updateNodeData = useCallback((nodeId: string, data: object, subNodeId?: string) => {
        saveStateForUndo();
        setNodes(nds => nds.map(node => {
            if (node.id === nodeId) {
                if (subNodeId && node.data.subgraph?.nodes) {
                    const newSubgraphNodes = node.data.subgraph.nodes.map(subNode => {
                        if (subNode.id === subNodeId) {
                            return { ...subNode, data: { ...subNode.data, ...data } };
                        }
                        return subNode;
                    });
                    return { ...node, data: { ...node.data, subgraph: { ...node.data.subgraph, nodes: newSubgraphNodes } } };
                }
                return { ...node, data: { ...node.data, ...data } };
            }
            return node;
        }));
    }, [saveStateForUndo]);
    
    const onSelectionChange = useCallback((params: OnSelectionChangeParams) => {
        setSelectedNode(params.nodes.length === 1 ? params.nodes[0] : null);
        setSelectedNodesForGrouping(params.nodes);
    }, []);

    const onDrop = useCallback((event: React.DragEvent) => {
        event.preventDefault();
        const type = event.dataTransfer.getData('application/reactflow');
        if (!type) return;

        const position = screenToFlowPosition({ x: event.clientX, y: event.clientY });
        const newId = `${getId()}`;
        let newNode: Node;

        switch (type) {
            case 'fmOperator':
                newNode = { id: newId, type, position, data: { 
                    label: `FM Operator`,
                    frequency: 440,
                    modIndex: 100,
                    exposedParameters: ['frequency', 'modIndex']
                }};
                break;
            case 'wavetable':
                newNode = { id: newId, type, position, data: { 
                    label: `Wavetable`,
                    tableName: 'Sine',
                    frequency: 440,
                    position: 0,
                    exposedParameters: ['frequency', 'position']
                }};
                break;
            case 'sampleHold':
                newNode = { id: newId, type, position, data: { 
                    label: `S & H`,
                    rate: 10.0,
                    amplitude: 1.0,
                    bpmSync: false,
                    syncRate: '1/8',
                    exposedParameters: ['rate', 'amplitude']
                }};
                break;
            case 'lfo':
                newNode = { id: newId, type, position, data: { 
                    label: `LFO`, 
                    waveform: "Sine",
                    frequency: 5.0,
                    amplitude: 1.0,
                    bpmSync: false,
                    syncRate: '1/4',
                    exposedParameters: ['frequency', 'amplitude']
                }};
                break;
            case 'oscillator':
                newNode = { id: newId, type, position, data: { 
                    label: `Oscillator`, 
                    frequency: 440.0, 
                    waveform: "Sawtooth",
                    amplitude: 0.5,
                    pulseWidth: 0.5,
                    phase: 0,
                    exposedParameters: ['frequency', 'amplitude', 'pulseWidth', 'phase']
                }};
                break;
            case 'filter':
                newNode = { id: newId, type, position, data: { 
                    label: `Filter`, 
                    type: 'Lowpass', 
                    cutoff: 800.0,
                    resonance: 1.0,
                    exposedParameters: ['cutoff', 'resonance']
                }};
                break;
            case 'noise':
                newNode = { id: newId, type, position, data: { 
                    label: `Noise`, 
                    type: 'White',
                    amplitude: 1.0,
                    exposedParameters: ['amplitude']
                }};
                break;
            case 'adsr':
                newNode = { id: newId, type, position, data: { 
                    label: `ADSR`, 
                    attack: 0.1, 
                    decay: 0.2, 
                    sustain: 0.5, 
                    release: 1.0,
                    amount: 1.0,
                    velocitySensitivity: 0.5,
                    attackCurve: 'linear',
                    decayCurve: 'linear',
                    releaseCurve: 'linear',
                    exposedParameters: ['attack', 'decay', 'sustain', 'release', 'amount']
                }};
                break;
            case 'delay':
                newNode = { id: newId, type, position, data: {
                    label: 'Delay',
                    delayTime: 0.5,
                    feedback: 0.5,
                    mix: 0.5,
                    bpmSync: false,
                    syncRate: '1/8',
                    exposedParameters: ['delayTime', 'feedback', 'mix']
                }};
                break;
            case 'reverb':
                newNode = { id: newId, type, position, data: {
                    label: 'Reverb',
                    decay: 3.0,
                    preDelay: 0.01,
                    mix: 0.5,
                    exposedParameters: ['decay', 'mix']
                }};
                break;
            case 'distortion':
                newNode = { id: newId, type, position, data: {
                    label: 'Distortion',
                    drive: 20,
                    tone: 4000,
                    mix: 0.5,
                    exposedParameters: ['drive', 'tone', 'mix']
                }};
                break;
            case 'mixer':
                newNode = { id: newId, type, position, data: {
                    label: 'Mixer',
                    inputCount: 4,
                    level1: 0.75, level2: 0.75, level3: 0.75, level4: 0.75,
                    exposedParameters: ['level1', 'level2', 'level3', 'level4']
                }};
                break;
            case 'panner':
                newNode = { id: newId, type, position, data: {
                    label: 'Panner',
                    pan: 0,
                    exposedParameters: ['pan']
                }};
                break;
            case 'output':
                newNode = { id: newId, type, position, data: { label: `Output` } };
                break;
            default:
                return;
        }
        setNodes((nds) => nds.concat(newNode));
    }, [screenToFlowPosition]);

    const handleUndo = useCallback(() => {
        if (history.length === 0) return;
        isRestoring.current = true;
        const lastState = history[history.length - 1];
        setHistory(history.slice(0, -1));
        setFuture(prevFuture => [ { nodes, edges }, ...prevFuture]);
        setNodes(lastState.nodes);
        setEdges(lastState.edges);
        isRestoring.current = false;
    }, [history, nodes, edges]);

    const handleRedo = useCallback(() => {
        if (future.length === 0) return;
        isRestoring.current = true;
        const nextState = future[0];
        setFuture(future.slice(1));
        setHistory(prevHistory => [...prevHistory, { nodes, edges }]);
        setNodes(nextState.nodes);
        setEdges(nextState.edges);
        isRestoring.current = false;
    }, [future, nodes, edges]);

    const handleCreateInstrument = useCallback(() => {
        if (selectedNodesForGrouping.length <= 1) return;
        setIsNamePromptVisible(true);
    }, [selectedNodesForGrouping]);

    const handleInstrumentNameSubmit = (instrumentName: string) => {
        const newInstrumentId = `${getId()}`;
        const selectedIds = new Set(selectedNodesForGrouping.map(n => n.id));

        const oldIdToNewIdMap = new Map<string, string>();
        let subGraphNodeIdCounter = 1;
        const subgraphNodes: Node[] = selectedNodesForGrouping.map(node => {
            const newId = `${subGraphNodeIdCounter++}`;
            oldIdToNewIdMap.set(node.id, newId);
            return { ...node, id: newId, data: JSON.parse(JSON.stringify(node.data)), position: { ...node.position } };
        });

        const internalConnections = edges.filter(edge => selectedIds.has(edge.source) && selectedIds.has(edge.target));
        const subgraphConnections = internalConnections.map(edge => ({
            from_node: oldIdToNewIdMap.get(edge.source)!,
            from_port: edge.sourceHandle || 'output',
            to_node: oldIdToNewIdMap.get(edge.target)!,
            to_port: edge.targetHandle || 'input',
        }));

        const externalEdges = edges.filter(edge => selectedIds.has(edge.source) !== selectedIds.has(edge.target));
        const newMainGraphEdges: Edge[] = edges.filter(e => !selectedIds.has(e.source) && !selectedIds.has(e.target));
        
        const inputPorts = new Map<string, { id: string }>();
        const outputPorts = new Map<string, { id: string }>();

        externalEdges.forEach(edge => {
            if (selectedIds.has(edge.target)) {
                const portName = edge.targetHandle || 'input';
                if (!inputPorts.has(portName)) {
                    const newInputNodeId = `${subGraphNodeIdCounter++}`;
                    inputPorts.set(portName, { id: newInputNodeId });
                    subgraphNodes.push({
                        id: newInputNodeId,
                        type: 'InstrumentInput',
                        position: { x: 50, y: (inputPorts.size + 1) * 70 },
                        data: { label: `In: ${portName}`, name: portName },
                    });
                }
                subgraphConnections.push({
                    from_node: inputPorts.get(portName)!.id,
                    from_port: 'output',
                    to_node: oldIdToNewIdMap.get(edge.target)!,
                    to_port: portName,
                });
                newMainGraphEdges.push({ ...edge, id: `e${edge.source}-${newInstrumentId}`, target: newInstrumentId, targetHandle: portName });

            } else { 
                const portName = edge.sourceHandle || 'output';
                if (!outputPorts.has(portName)) {
                    const newOutputNodeId = `${subGraphNodeIdCounter++}`;
                    outputPorts.set(portName, { id: newOutputNodeId });
                    subgraphNodes.push({
                        id: newOutputNodeId,
                        type: 'InstrumentOutput',
                        position: { x: 400, y: (outputPorts.size + 1) * 70 },
                        data: { label: `Out: ${portName}`, name: portName },
                    });
                }
                subgraphConnections.push({
                    from_node: oldIdToNewIdMap.get(edge.source)!,
                    from_port: portName,
                    to_node: outputPorts.get(portName)!.id,
                    to_port: 'input',
                });
                newMainGraphEdges.push({ ...edge, id: `e${newInstrumentId}-${edge.target}`, source: newInstrumentId, sourceHandle: portName });
            }
        });

        const avgPosition = selectedNodesForGrouping.reduce(
            (acc, node) => ({ x: acc.x + node.position.x, y: acc.y + node.position.y }), { x: 0, y: 0 }
        );
        if (selectedNodesForGrouping.length > 0) {
            avgPosition.x /= selectedNodesForGrouping.length;
            avgPosition.y /= selectedNodesForGrouping.length;
        }

        const newInstrumentNode: Node = {
            id: newInstrumentId,
            type: 'instrument',
            position: avgPosition,
            data: {
                name: instrumentName,
                label: instrumentName,
                voiceCount: 8,
                voiceStealing: 'oldest',
                glide: 0.05,
                unison: 1,
                detune: 5,
                inputs: Array.from(inputPorts.keys()),
                outputs: Array.from(outputPorts.keys()),
                subgraph: {
                    nodes: subgraphNodes,
                    connections: subgraphConnections,
                },
            },
        };
        
        saveStateForUndo();
        const remainingNodes = nodes.filter(n => !selectedIds.has(n.id));
        setNodes([...remainingNodes, newInstrumentNode]);
        setEdges(newMainGraphEdges);
        setIsNamePromptVisible(false);
    };

    const handleCreateGroup = useCallback(() => {
        if (selectedNodesForGrouping.length <= 1) return;

        saveStateForUndo();

        const selectedIds = new Set(selectedNodesForGrouping.map(n => n.id));
        const newGroupId = `group-${getId()}`;
        
        const minX = Math.min(...selectedNodesForGrouping.map(n => n.position.x));
        const minY = Math.min(...selectedNodesForGrouping.map(n => n.position.y));
        const maxX = Math.max(...selectedNodesForGrouping.map(n => n.position.x + (n.width || 150)));
        const maxY = Math.max(...selectedNodesForGrouping.map(n => n.position.y + (n.height || 50)));

        const padding = 40;
        const groupNodePosition = { x: minX - padding, y: minY - padding };

        const newGroupNode: Node = {
            id: newGroupId,
            type: 'group',
            position: groupNodePosition,
            data: { label: 'New Group' },
            style: { 
                width: maxX - minX + (padding * 2), 
                height: maxY - minY + (padding * 2),
            }
        };

        const updatedNodes = nodes.map(n => {
            if (selectedIds.has(n.id)) {
                return { 
                    ...n, 
                    parentNode: newGroupId, 
                    extent: 'parent',
                    position: {
                        x: n.position.x - groupNodePosition.x,
                        y: n.position.y - groupNodePosition.y,
                    },
                };
            }
            return n;
        });

        setNodes([...updatedNodes, newGroupNode]);
    }, [nodes, selectedNodesForGrouping, saveStateForUndo]);

    return {
        nodes,
        edges,
        setNodes,
        setEdges,
        selectedNode,
        selectedNodesForGrouping,
        isNamePromptVisible,
        setIsNamePromptVisible,
        onNodesChange,
        onEdgesChange,
        onConnect,
        updateNodeData,
        onDrop,
        onSelectionChange,
        handleUndo,
        handleRedo,
        handleCreateInstrument,
        handleInstrumentNameSubmit,
        handleCreateGroup,
    };
};


--- END FILE: hooks/nodeEditor/useGraphState.ts ---

--- START FILE: hooks/nodeEditor/voice.ts ---

// skald-ui/src/hooks/nodeEditor/voice.ts
import { Node, Edge } from 'reactflow';
import { createAudioNode, connectNodes, AudioNodeMap, AdsrDataMap } from './useAudioEngine'; // We will export these types from the main hook

export class Voice {
    private audioContext: AudioContext;
    private internalNodes: AudioNodeMap = new Map();
    private adsrData: AdsrDataMap = new Map();
    private output: GainNode;
    private subgraph: { nodes: Node[]; edges: Edge[] };

    constructor(context: AudioContext, subgraph: { nodes: Node[]; edges: Edge[] }) {
        this.audioContext = context;
        this.subgraph = subgraph;
        this.output = this.audioContext.createGain();
        this.buildSubgraph();
    }

    private buildSubgraph() {
        // 1. Create all internal audio nodes
        this.subgraph.nodes.forEach(node => {
            const audioNode = createAudioNode(this.audioContext, node, this.adsrData);
            if (audioNode) {
                this.internalNodes.set(node.id, audioNode);
            }
        });

        // 2. Connect the internal nodes
        this.subgraph.edges.forEach(edge => {
            const sourceNode = this.internalNodes.get(edge.source);
            const targetNode = this.internalNodes.get(edge.target);
            if (sourceNode && targetNode) {
                connectNodes(sourceNode, targetNode, edge);
            }
        });

        // 3. Connect the final output of the subgraph to the voice's main output
        const outputNode = this.subgraph.nodes.find(n => n.type === 'output');
        if (outputNode) {
            const finalInternalNode = this.internalNodes.get(outputNode.id);
            if(finalInternalNode) {
                finalInternalNode.connect(this.output);
            }
        }
    }

    public trigger(startTime: number) {
        this.adsrData.forEach(({ gainNode, data }) => {
            const { attack = 0.01, decay = 0.1, sustain = 0.8 } = data;
            gainNode.gain.cancelScheduledValues(startTime);
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(1, startTime + attack);
            gainNode.gain.linearRampToValueAtTime(sustain, startTime + attack + decay);
        });
    }

    public release(startTime: number) {
        this.adsrData.forEach(({ gainNode, data }) => {
            const { release = 0.5 } = data;
            const currentGain = gainNode.gain.value;
            gainNode.gain.cancelScheduledValues(startTime);
            gainNode.gain.setValueAtTime(currentGain, startTime);
            gainNode.gain.linearRampToValueAtTime(0, startTime + release);
        });
    }

    public connect(destination: AudioNode | AudioParam) {
        this.output.connect(destination);
    }

    public disconnect() {
        this.output.disconnect();
        this.internalNodes.forEach(node => node.disconnect());
    }

    public updateNodeData(nodeId: string, data: any) {
        const nodeToUpdate = this.internalNodes.get(nodeId);
        const nodeDef = this.subgraph.nodes.find(n => n.id === nodeId);
        if (!nodeToUpdate || !nodeDef) return;

        const now = this.audioContext.currentTime;
        const rampTime = 0.02;

        if (nodeToUpdate instanceof OscillatorNode) {
            if (data.frequency !== undefined) nodeToUpdate.frequency.setTargetAtTime(data.frequency, now, rampTime);
        } else if (nodeToUpdate instanceof BiquadFilterNode) {
            if (data.cutoff !== undefined) nodeToUpdate.frequency.setTargetAtTime(data.cutoff, now, rampTime);
            if (data.resonance !== undefined) nodeToUpdate.Q.setTargetAtTime(data.resonance, now, rampTime);
        } else if (nodeToUpdate instanceof GainNode && nodeDef.type === 'adsr') {
            const adsr = this.adsrData.get(nodeId);
            if (adsr) adsr.data = { ...adsr.data, ...data };
        }
    }
}

--- END FILE: hooks/nodeEditor/voice.ts ---

--- START FILE: index.css ---

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  width: 100%;
  overflow: hidden; /* Prevents scrollbars on the main body */
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica,
    Arial, sans-serif;
}

#root {
  height: 100%;
  width: 100%;
}

.react-flow__node.selected {
  border: 2px solid #5a67d8; /* A bright, clear blue */
  box-shadow: 0 0 15px rgba(90, 103, 216, 0.5); /* A subtle glow effect */
}

--- END FILE: index.css ---

--- START FILE: main.ts ---

// main.ts
import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import path from 'node:path';
import fs from 'node:fs';
import { spawn } from 'child_process';
import started from 'electron-squirrel-startup';

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (started) {
  app.quit();
}

const createWindow = () => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // and load the index.html of the app.
  if (MAIN_WINDOW_VITE_DEV_SERVER_URL) {
    mainWindow.loadURL(MAIN_WINDOW_VITE_DEV_SERVER_URL);
  } else {
    mainWindow.loadFile(path.join(__dirname, `../renderer/${MAIN_WINDOW_VITE_NAME}/index.html`));
  }

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

app.on('ready', createWindow);

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

ipcMain.handle('invoke-codegen', async (_, graphJson: string) => {
    // --- DEBUG: Log the JSON received by the main process ---
    console.log("Main process received from renderer:", graphJson);
    // ---------------------------------------------------------

    // In dev mode, app.getAppPath() points to the project root.
    // In production, it would point to the app's resource directory.
    const executablePath = path.join(app.getAppPath(), 'skald_codegen.exe');
    
    return new Promise((resolve, reject) => {
        const child = spawn(executablePath);

        let stdout = '';
        let stderr = '';

        child.stdout.on('data', (data) => {
            stdout += data.toString();
        });

        child.stderr.on('data', (data) => {
            // --- DEBUG: This will print any debug statements from the Odin backend ---
            console.error(`[Odin STDERR]: ${data.toString()}`);
            // -------------------------------------------------------------------------
            stderr += data.toString();
        });

        child.on('close', (code) => {
            if (code === 0) {
                console.log("Codegen successful.");
                resolve(stdout);
            } else {
                console.error(`Codegen failed with code ${code}: ${stderr}`);
                reject(new Error(stderr || `Codegen process exited with code ${code}`));
            }
        });

        child.on('error', (err) => {
            console.error(`Failed to start codegen process: ${err.message}`);
            reject(err);
        });

        child.stdin.write(graphJson);
        child.stdin.end();
    });
});


// Handler for saving the graph
ipcMain.handle('save-graph', async (_, graphJson: string) => {
  const { filePath } = await dialog.showSaveDialog({
    title: 'Save Skald Graph',
    buttonLabel: 'Save',
    defaultPath: `skald-graph-${Date.now()}.json`,
    filters: [{ name: 'Skald Files', extensions: ['json'] }],
  });

  if (filePath) {
    fs.writeFileSync(filePath, graphJson);
  }
});

// Handler for loading the graph
ipcMain.handle('load-graph', async () => {
  const { filePaths } = await dialog.showOpenDialog({
    title: 'Load Skald Graph',
    buttonLabel: 'Load',
    properties: ['openFile'],
    filters: [{ name: 'Skald Files', extensions: ['json'] }],
  });

  if (filePaths && filePaths.length > 0) {
    const content = fs.readFileSync(filePaths[0], 'utf-8');
    return content;
  }
  return null;
});

--- END FILE: main.ts ---

--- START FILE: preload.ts ---

// weaseyp/skald/Skald-c85dd551104648b52e55e6e766bc5760cea28853/skald-ui/src/preload.ts
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electron', {
    invokeCodegen: (graphJson: string): Promise<string> => 
        ipcRenderer.invoke('invoke-codegen', graphJson),
    
    saveGraph: (graphJson: string): Promise<void> =>
        ipcRenderer.invoke('save-graph', graphJson),
        
    loadGraph: (): Promise<string | null> =>
        ipcRenderer.invoke('load-graph'),
});

--- END FILE: preload.ts ---

--- START FILE: renderer.tsx ---

// src/renderer.tsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import { ReactFlowProvider } from 'reactflow';
import App from './app';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ReactFlowProvider>
      <App />
    </ReactFlowProvider>
  </React.StrictMode>
);

--- END FILE: renderer.tsx ---

